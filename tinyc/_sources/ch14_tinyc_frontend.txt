第14章 TinyC 前端
====================

上一章介绍了 bison 中一些常用功能的使用方法，bison 是一个非常强大的语法分析工具，读者还可以阅读一下 bison 的文档进行更深入的学习。本章介绍如何利用 flex 和 bison 实现 TinyC 编译器的前端，建议读者先复习一下 **第 5 章 手工编译 TinyC** ，再来看本章的代码。

14.1 第 0.1 版
---------------
首先对上一章的雏形版本稍微升级一下，增加变量声明和 print 语句，一共有 5 个文件：

词法分析文件： :download:`scanner.l </_src/ch14/p0.1/scanner.l>`

.. literalinclude:: /_src/ch14/p0.1/scanner.l
    :language: c

语法分析文件： :download:`parser.y </_src/ch14/p0.1/parser.y>`

.. literalinclude:: /_src/ch14/p0.1/parser.y
    :language: c

makefile 文件： :download:`makefile </_src/ch14/p0.1/makefile>`

.. literalinclude:: /_src/ch14/p0.1/makefile
    :language: makefile

测试文件： :download:`test.c </_src/ch14/p0.1/test.c>`

.. literalinclude:: /_src/ch14/p0.1/test.c
    :language: c

Pcode 模拟器： :download:`pysim.py </_src/ch14/p0.1/pysim.py>` ，已经在第 4 章中介绍了。

这个版本在上一章的雏形版本的基础上，进行了以下扩充：
    
    词法分析文件中：

        增加了 T_StringConstant, T_Int, T_Print 类型的 token ，以及相应的正则表达式；

        增加了一个 _DUPTEXT 宏，表示 yylval = strdup(yytext) 。

    语法分析文件中：

        增加了 VarDecl 和 Print 两个非终结符以及相应的产生式。

本版本的语法分析文件中，同样要注意源文件的解析过程中各产生式的折叠顺序以及相应的 Pcode 生成顺序。

makefile 里面是编译和测试这个程序的命令，在终端输入 make 后，将编译生成可执行文件 tcc ，然后输入 make test ，（相当于 "./tcc < test.c > test.asm" ） ，将输出 test.asm 文件，内容如下：

.. literalinclude:: /_src/ch14/p0.1/test.asm
    :language: text

可以看出 test.c 文件里的所有语句都被转换成相应的 Pcode 了。再用 Pcode 模拟器运行一下这些 Pcode ，在终端输入 "make simulate" （相当于 "python pysim.py test.asm" ） ，将输出：

.. code-block:: text
    
    a = 9, b = 5, c = 10, d = 15

14.2 第 0.5 版
-----------------
在第 0.1 版的基础上升级，增加函数定义及调用语句、注释等功能，一共有 5 个文件：

词法分析文件： :download:`scanner.l </_src/ch14/p0.5/scanner.l>`

.. literalinclude:: /_src/ch14/p0.5/scanner.l
    :language: c

语法分析文件： :download:`parser.y </_src/ch14/p0.5/parser.y>`

.. literalinclude:: /_src/ch14/p0.5/parser.y
    :language: c

makefile 文件： :download:`makefile </_src/ch14/p0.5/makefile>`， 和第 0.1 版本中唯一不同的只有 "python pysim.py $< -a" 那一行有一个 **\"-a\"** 。

测试文件： :download:`test.c </_src/ch14/p0.5/test.c>`

.. literalinclude:: /_src/ch14/p0.5/test.c
    :language: c

Pcode 模拟器： :download:`pysim.py </_src/ch14/p0.5/pysim.py>` ，已经在第 4 章中介绍了。

这个版本在第 0.1 版本的基础上，进行了以下扩充：
    
    词法分析文件中：

        增加了 T_Void 和 T_Return 类型的 token ，以及相应的正则表达式；

        增加了单行注释的过滤功能；增加了一个错误处理函数： unterminate_string ，该函数可以检查出未结束的字符串（不匹配的双引号）的词法错误。

    语法分析文件中：

        增加了 Program, FuncDecl, Args, Actuals, CallExpr 等非终结符以及相应的产生式，请注意各产生式的折叠顺序以及相应的 Pcode 生成顺序。

makefile 里面是编译和测试这个程序的命令，内容和第 0.1 版的基本一样，但增加了一些变量以便于扩充，另外，"python pysim.py..." 那一行最后的命令行参数是 **\"\-a\"** 。在终端输入 make 后，将编译生成可执行文件 tcc ，然后输入 make test ，（相当于 "./tcc < test.c > test.asm" ） ，将输出 test.asm 文件，内容如下：

.. literalinclude:: /_src/ch14/p0.5/test.asm
    :language: text

可以看出 test.c 文件里的所有语句都被转换成相应的 Pcode 了。再用 Pcode 模拟器运行一下这些 Pcode ，在终端输入 "make simulate" （相当于 "python pysim.py test.asm -a" ，注意最后有一个 **"-a"** ） ，将输出：

.. code-block:: text
    
    c = 2, d = 4
    a = sum(c, d) = 6, b = sum(a, d) = 10

有兴趣的读者还可以使用 "python pysim.py test.asm -da" 来逐句运行一下这个 Pcode 文件。


14.3 第 1.0 版
---------------
继续在第 0.5 版的基础上升级，增加 if 和 while 语句、比较运算符和逻辑运算符以及 readint 命令，就形成了完整的 TinyC 前端。一共有 7 个文件：

词法分析文件： :download:`scanner.l </_src/ch14/p1.0/scanner.l>`

.. literalinclude:: /_src/ch14/p1.0/scanner.l
   :language: c
   :emphasize-lines: 33-44

语法分析文件： :download:`parser.y </_src/ch14/p1.0/parser.y>`

.. literalinclude:: /_src/ch14/p1.0/parser.y
   :language: c
   :emphasize-lines: 7-16, 20-31, 126-213

makefile 文件： :download:`makefile </_src/ch14/p1.0/makefile>` ，内容和 第 0.5 版是一样的。

测试文件： :download:`test.c </_src/ch14/p1.0/test.c>` ，就是第二章的的示例源程序。

.. literalinclude:: /_src/ch14/p1.0/test.c
   :language: c

测试文件包：:download:`samples.zip </_src/ch14/p1.0/samples.zip>` ，包含了 7 个测试文件。

测试脚本： :download:`test_samples.sh </_src/ch14/p1.0/test_samples.sh>` 。

Pcode 模拟器： :download:`pysim.py </_src/ch14/p1.0/pysim.py>` 。

这个版本在第 0.1 版本的基础上，进行了以下扩充：
    
    词法分析文件中：

        增加了 T_Void 和 T_Return 类型的 token ，以及相应的正则表达式。

    语法分析文件中：

        增加了 IfStmt, WhileStmt, BreakStmt, ContinueStmt, ReadInt 等非终结符以及相应的产生式，请注意各产生式的折叠顺序以及相应的 Pcode 生成顺序；

        增加了比较运算符、逻辑运算符，以及相应的优先级；

        在 Declarations 段，增加了几个全局变量和宏：

            .. literalinclude:: /_src/ch14/p1.0/parser.y
               :language: c
               :lines: 7-16
        
        这些全局变量和宏配合后面的 if/while 语句产生式中的 action 使用，是该文件中的最精妙的部分，它们的作用是：在生成 if 和 while 语句块的 Pcode 的过程中，给相应的 Label 进行编号。它们给每个 if 语句块和每个 while 语句块一个唯一的编号，使不同的 if/while 语句块的 jmp 不相互冲突。其中 _i 永远是当前的 if 语句块的编号， _w 永远是当前的 while 语句块的编号； ii/ww 永远是目前解析到的 if/while 语句块的总数。

将以上所有文件都放在当前目录，在终端直接输入 make test ，将自动编译生成 TinyC 前端： **tcc** ，并自动调用 tcc 将 test.c 编译成 test.asm 文件，内容如下，和第 5 章的手工编译的结果差不多吧：

.. literalinclude:: /_src/ch14/p1.0/test.asm
   :language: text

再输入 "make simulate"，将输出：

.. code-block:: text
    
    1! = 1
    2! = 2
    4! = 24
    6! = 720
    7! = 5040

和第二章中用 gcc 编译并运行此文件的结果完全一样。

再把测试文件包里的所有源文件全部测试一遍，将 :download:`samples.zip </_src/ch14/p1.0/samples.zip>` 解压到 samples 目录下，测试脚本 :download:`test_samples.sh </_src/ch14/p1.0/test_samples.sh>` 将分别调用 tcc 和 gcc 编译测试文件包中的每一个文件，并分别使用 pysim.py 和 操作系统 运行编译得到的目标文件，内容如下：

.. literalinclude:: /_src/ch14/p1.0/test_samples.sh
    :language: bash

在终端输入 bash ./test_samples.sh ，将分别输出一系列的结果，典型输出如下，可以看到 gcc 和 tcc 编译运行的结果完全一致。

.. code-block:: text

	build with tcc, the output are:
	The first 10 number of the fibonacci sequence:
	fib(1)=1
	fib(2)=1
	fib(3)=2
	fib(4)=3
	fib(5)=5
	fib(6)=8
	fib(7)=13
	fib(8)=21
	fib(9)=34
	fib(10)=55

	build with gcc, the output are:
	The first 10 number of the fibonacci sequence:
	fib(1)=1
	fib(2)=1
	fib(3)=2
	fib(4)=3
	fib(5)=5
	fib(6)=8
	fib(7)=13
	fib(8)=21
	fib(9)=34
	fib(10)=55


至此 TinyC 前端完成。

**第 14 章完**
