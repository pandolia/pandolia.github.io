<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第12章 自底向上分析 (下) &mdash; 自己动手写编译器</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="自己动手写编译器" href="index.html" />
    <link rel="next" title="第13章 用 bison 做语法分析" href="ch13_bison.html" />
    <link rel="prev" title="第11章 自底向上分析 (上)" href="ch11_buttom_up_parse_a.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch13_bison.html" title="第13章 用 bison 做语法分析"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="ch11_buttom_up_parse_a.html" title="第11章 自底向上分析 (上)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第12章 自底向上分析 (下)<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lr-1">
<h2>12.1 构造 LR(1) 分析器<a class="headerlink" href="#lr-1" title="Permalink to this headline">¶</a></h2>
<p>LR(0) 分析法要求语法的状态中不能有多条可折叠形态、且不能同时有可折叠形态和不可折叠形态，这是为了避免 reduce/reduce 冲突和 shift/reduce 冲突，此限制条件相当强，导致 LR(0) 的适用范围非常小。</p>
<p>事实上，只要对 LR(0) 法做一个很小的改进，就可以将这个限制条件去掉非常大的一部分。</p>
<p>这个可改进的地方就在于： LR(0) 法在执行 reduce 动作的时候没有利用下一个读入的符号的信息。</p>
<p>即便一个状态中含有多条可折叠形态，如： I = { &#8220;A -&gt; u.&#8221; ; &#8220;B -&gt; v.&#8221; } ，那么只要 Follow(A) 和 Follow(B) 不相交，就可以利用下一个符号 a 来选择折叠时需应用的产生式，如果 a 属于 Follow(A) ，那就 reduce &#8220;A -&gt; u&#8221; ，如果 a 属于 Follow(B) 那就 reduce &#8220;B -&gt; v&#8221; 。</p>
<p>shift/reduce 冲突同样可能避免，若一个状态中含有可折叠形态，也含有不可折叠形态，如： I = { &#8220;A -&gt; u.&#8221; ; &#8220;B -&gt; v.w&#8221; } ，那么只要 Follow(A) 和 First(w) 不相交，那也可以利用下一个符号 a 来选择需要执行的动作，如果 a 属于 Follow(A) ，那就 reduce ，如果 a 属于 First(w) 那就 shift 。</p>
<p>按以上思路，可以对 LR(0) 法进行一个小小的改进。但是还可以更进一步的，在形态中就绑定需要的下一个符号的信息，将上一章中的形态的格式改进一下，改进成下面这样的格式：</p>
<blockquote>
<div>A –&gt; X1 ... Xi • Xi+1 ... Xn , a</div></blockquote>
<p>上面这个形态代表着这样的解析状态：目前栈上的符号为 X1 ... Xi ，期待遇到 Xi+1 ... Xn 这一系列的符号，并且只有 Xn 后读入的终结符是 a 的时候才执行 reduce 动作。这个 a 被称为 <strong>预测先行（lookahead）</strong> 。</p>
<p>使用这种格式的形态的 LR 解析法称为 LR(1) 分析法，括号中的 1 表示需要 1 个 lookahead ，也就是只利用下一个读入符号的信息。LR(1) 的构造过程和 LR(0) 的构造过程几乎一样，以下仅介绍二者不同的地方。</p>
<p>新格式形态的后继形态、延伸形态：</p>
<blockquote>
<div><p><strong>后继形态（successor configuration）</strong> ：形态：</p>
<blockquote>
<div>C = [ A -&gt; X•YZ, a ]</div></blockquote>
<p>遇到符号 Y 的后转移到形态：</p>
<blockquote>
<div>C&#8217; = [ A -&gt; XY•Z, a ]</div></blockquote>
<p>C&#8217; 称为形态 C 遇到符号 Y 的后继形态，记为 NEXT(C, Y)。</p>
<p><strong>延伸形态（extended configuration）</strong> ： 若一个形态 C 的黑点后面是非终结符 B ，即：</p>
<blockquote>
<div>C = [ A -&gt; u.Bv, a ]</div></blockquote>
<p>且有： B -&gt; w ， b ∈ First(va) 。则形态：</p>
<blockquote>
<div>C&#8217; = [ B -&gt; .w, b ]</div></blockquote>
<p>是形态 C 的延伸形态。也就是说， C&#8217; 中的产生式左边的非终结符就是 C 中黑点后面的非终结符，且 C&#8217; 中的 lookahead 是 First(va) 中的一个符号（其中 v 是形态 C 中 B 后面的符号串， a 是形态 C 的lookahead）。</p>
<p>例如：</p>
<blockquote>
<div><p>若 C = [ A -&gt; b.BDd, a ] ，且 B 和 D 的产生式为： B -&gt; c ，D -&gt; e | f ，则 First(Dda) = {e, f} ，因此形态：</p>
<blockquote>
<div>[ B -&gt; .c, e ] 和 [ B -&gt; .c, f ]</div></blockquote>
<p>都是 C 的延伸形态。</p>
</div></blockquote>
<p>为什么 C&#8217; 中的 lookahead 是 First(va) 中的符号呢？我们再观察一下形态 C ：</p>
<blockquote>
<div>C = [ A -&gt; u.Bv, a ]</div></blockquote>
<p>这个形态表明目前栈上的符号串是 u ，期待遇到符号 B ，再遇到符号串 v ，最后遇到 a 时才能折叠。因此，要折叠形态 C&#8217; 得到符号 B ，遇到的终结符 b 必须得是 C 中的 B 后面的终结符，也就是 First(v) ，但如果 First(v) 中含有 ε 呢，这时就一定得遇到符号 a 才能折叠。因此： b 必须得是 First(va) 中的符号。</p>
<p>进一步，若 C&#8217;&#8217; 是 C&#8217; 的延伸形态，则 C&#8217;&#8217; 也是 C 的延伸形态。这里再次强调一下：延伸的方向是单向的。</p>
</div></blockquote>
<p>新格式形态的相关操作和上一章的几乎是一模一样的：</p>
<blockquote>
<div><p><strong>形态集合的闭合（closure of a configurating set）</strong> ：闭合操作步骤（设集合名为 I）：</p>
<blockquote>
<div><p>（1） 遍历 I ，对 I 中的每一条黑点后是非终结符的形态 [ A -&gt; u.Bv , a ] ，对 B 的每一个产生式 B -&gt; w 、以及 First(va) 中的每一个符号 b ，将形态  [ B -&gt; .w, b ] 添加进 I 。</p>
<p>（2） 重复（1），直到不再出现新的形态。</p>
</div></blockquote>
<p>闭合操作的得到的新集合 I&#8217; 仍然称为原集合 I 的 <strong>闭包集合</strong> ，记为 CLOSURE(I) 。</p>
<p><strong>上下文无关语法的起始状态（start state of a CFG）</strong> ： 若一个 CFG 的起始符号 S 的所有产生式为 S -&gt; u1 | u2 | ... | un ，且 S 不位于任何产生式的右边，则其起始状态（记为 I0 ）是以下形态的集合的闭包集合，即：</p>
<blockquote>
<div>I0 = CLOSURE( { [S-&gt;.u1, $], [S-&gt;.u2, $] , ... [S-&gt;.un, $] } )</div></blockquote>
<p><strong>后继状态（succesor state）</strong> ： 当状态 I 遇到符号 X 时，可能转移到另一个状态，称此状态为状态 I 遇到符号 X 的后继状态，记为 NEXT(I, X) ，按下式计算：</p>
<blockquote>
<div>NEXT(I, X) = CLOSURE( { NEXT(C, X) | C ∈ I } )</div></blockquote>
<p>NEXT(I, X) 的计算步骤为：</p>
<blockquote>
<div><p>（1） 置 I&#8217; 为空集。</p>
<p>（2） 遍历 I ，对 I 中每一条形态 C ，若 NEXT(C, X) 存在，则将 NEXT(C, X) 加入 I&#8217; 。</p>
<p>（3） 对 I&#8217; 进行闭合操作。</p>
</div></blockquote>
<p>注意，NEXT(I, X) 可能为空集。</p>
</div></blockquote>
<p>来看一个简单的例子吧：</p>
<div class="highlight-text"><div class="highlight"><pre>0) S&#39; –&gt; S
1) S –&gt; XX
2) X –&gt; aX
3) X –&gt; b
</pre></div>
</div>
<p>首先算出所有符号的 first set ： First(S) = First(S&#8217;) = First(X) = {a, b} 。</p>
<p>起始状态 I0 = CLOSURE( { &#8220;S&#8217; -&gt; .S , $&#8221; } ) ：</p>
<div class="highlight-text"><div class="highlight"><pre>I0:
    S&#39; –&gt; .S  , $
    S  –&gt; .XX , $
    X  –&gt; .aX , a/b
    X  –&gt; .b  , a/b
</pre></div>
</div>
<p>上面的 &#8220;X  –&gt; .aX , a/b&#8221; 是两条形态 &#8220;X  –&gt; .aX , a&#8221; 和 &#8220;X  –&gt; .aX , b&#8221; 的简写。</p>
<p>还是按上一章的步骤，对语法中的所有符号 X （S&#8217;, S, X, a, b） ，求出 I0 遇到 X 的后继状态 I1 = NEXT(I0, X) ，若 I1 不是空集，则将其添加到状态转移表中，然后不断重复，直到无法生成新的状态，最终的状态转移表的图形如下：</p>
<a class="reference internal image-reference" href="images/lr1_1.png"><img alt="images/lr1_1.png" src="images/lr1_1.png" style="width: 769px; height: 414px;" /></a>
<p><strong>图12.1 状态转移图</strong></p>
<p>构造动作表 M 的步骤也和上一章的大致一样， M 中的 M[I, X] 表示栈顶状态为 I ，下一个符号为 X 时所应采取的动作，按以下情况确定：</p>
<blockquote>
<div><p>（1） NEXT(I, X) 存在（设为 I&#8217;）、 X 为终结符： M[I, X] = shift I&#8217; ；</p>
<p>（2） NEXT(I, X) 存在（设为 I&#8217;）、 X 为非终结符： M[I, X] = goto I&#8217; ；</p>
<p>（3） I 中含有形态 [ A -&gt; X1 X2 ... Xn • , X] ，有以下两种情况：</p>
<blockquote>
<div><p>（3.1） A != S 或 X != $ ： M[I, X] = reduce A -&gt; X1 X2 ... Xn ；</p>
<p>（3.2） A == S 且 X == $ ： M[I, X] = accept ；</p>
</div></blockquote>
<p>（4） 其他所有情况： M[I, X] = deny 。</p>
</div></blockquote>
<p>按以上步骤以及图12.1，构造出的动作表 M 如下，其中 M[I, X] 为空白的表示 deny 动作：</p>
    <table border="1" class="hcjtable">
    <colgroup>
            <col width="40"  />
            <col width="160" />
            <col width="160" />
            <col width="160" />
            <col width="120" />
            <col width="120" />
    </colgroup>
    <tr>
            <th></th>
    <th>a</th>
            <th>b</th>
            <th>$</th>
            <th>S</th>
            <th>X</th>
    </tr>
    <tr>
            <th>I0</th>
            <td>shift I3</td>
            <td>shift I4</td>
            <td></td>
            <td>goto I1</td>
            <td>goto I2</td>
    </tr>
    <tr>
            <th>I1</th>
            <td></td>
            <td></td>
            <td>ACCEPT</td>
            <td></td>
            <td></td>
            </tr>
    <tr>
            <th>I2</th>
            <td>shift I6</td>
            <td>shift I7</td>
            <td></td>
            <td></td>
            <td>goto I5</td>
    </tr>
    <tr>
            <th>I3</th>
            <td>shift I3</td>
            <td>shift I4</td>
            <td></td>
            <td></td>
            <td>goto I8</td>
    </tr>
    <tr>
            <th>I4</th>
            <td>reduce X–&gtb</td>
            <td>reduce X–&gtb</td>
            <td></td>
            <td></td>
            <td></td>
    </tr>
    <tr>
            <th>I5</th>
            <td></td>
            <td></td>
            <td>reduce S–&gtXX</td>
            <td></td>
            <td></td>
    </tr>
    <tr>
            <th>I6</th>
            <td>shift I6</td>
            <td>shift I7</td>
            <td></td>
            <td></td>
            <td>goto I9</td>
    </tr>
    <tr>
            <th>I7</th>
            <td></td>
            <td></td>
            <td>reduce X–&gtb</td>
            <td></td>
            <td></td>
    </tr>
    <tr>
            <th>I8</th>
            <td>reduce X-&gtaX</td>
            <td>reduce X-&gtaX</td>
            <td></td>
            <td></td>
            <td></td>
    </tr>
    <tr>
            <th>I9</th>
            <td></td>
            <td></td>
            <td>reduce X-&gtaX</td>
            <td></td>
            <td></td>
    </tr>
    </tbody>
    </table><p>构造出动作表后，LR(1) 解析流程和 LR(0) 是一样的，详见上一章，下面对句子 &#8220;baab&#8221; 进行解析，全过程如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="20%" />
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="24%" />
<col width="1%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Sym-Stack</th>
<th class="head">State-Stack</th>
<th class="head">&nbsp;</th>
<th class="head">X</th>
<th class="head">&nbsp;</th>
<th class="head">x Remaining-Input</th>
<th class="head">&nbsp;</th>
<th class="head">Parse-Action</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td></td>
<td>I0</td>
<td>&nbsp;</td>
<td>b</td>
<td>&nbsp;</td>
<td>b aab$</td>
<td>&nbsp;</td>
<td>M[I0,b] = shift I4</td>
</tr>
<tr class="row-odd"><td>b</td>
<td>I0 I4</td>
<td>&nbsp;</td>
<td>a</td>
<td>&nbsp;</td>
<td>a ab$</td>
<td>&nbsp;</td>
<td>M[I4,a] = reduce X-&gt;b</td>
</tr>
<tr class="row-even"><td></td>
<td>I0</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>a ab$</td>
<td>&nbsp;</td>
<td>M[I0,X] = goto I2</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>I0 I2</td>
<td>&nbsp;</td>
<td>a</td>
<td>&nbsp;</td>
<td>a ab$</td>
<td>&nbsp;</td>
<td>M[I2,a] = shift I6</td>
</tr>
<tr class="row-even"><td>Xa</td>
<td>I0 I2 I6</td>
<td>&nbsp;</td>
<td>a</td>
<td>&nbsp;</td>
<td>a b$</td>
<td>&nbsp;</td>
<td>M[I6,a] = shift I6</td>
</tr>
<tr class="row-odd"><td>Xaa</td>
<td>I0 I2 I6 I6</td>
<td>&nbsp;</td>
<td>b</td>
<td>&nbsp;</td>
<td>b $</td>
<td>&nbsp;</td>
<td>M[I6,b] = shift I7</td>
</tr>
<tr class="row-even"><td>Xaab</td>
<td>I0 I2 I6 I6 I7</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I7,$] = reduce X-&gt;b</td>
</tr>
<tr class="row-odd"><td>Xaa</td>
<td>I0 I2 I6 I6</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I6,X] = goto I9</td>
</tr>
<tr class="row-even"><td>XaaX</td>
<td>I0 I2 I6 I6 I9</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I9,$] = reduce X-&gt;aX</td>
</tr>
<tr class="row-odd"><td>Xa</td>
<td>I0 I2 I6</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I6,X] = goto I9</td>
</tr>
<tr class="row-even"><td>XaX</td>
<td>I0 I2 I6 I9</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I9,$] = reduce X-&gt;aX</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>I0 I2</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I2,X] = goto I5</td>
</tr>
<tr class="row-even"><td>XX</td>
<td>I0 I2 I5</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I5,$] = reduce S–&gt;XX</td>
</tr>
<tr class="row-odd"><td></td>
<td>I0</td>
<td>&nbsp;</td>
<td>S</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I0,$] = goto I1</td>
</tr>
<tr class="row-even"><td>S</td>
<td>I0 I1</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>$</td>
<td>&nbsp;</td>
<td>M[I1,$] = <strong>ACCEPT</strong></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id2">
<h2>12.2 LR(1) 分析法的要求<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>和 LR(0) 分析法相比， LR(1) 利用了 lookahead 的信息后，其解析力量和适用范围有了质的飞跃，一个状态中可以同时含有可折叠形态和不可折叠形态（只要可折叠形态的 lookahead 不和不可折叠形态中黑点后面的符号冲突），也可以同时含有多条可折叠形态（只要这些可折叠形态的 lookahead 不相互冲突）。</p>
<p>LR(1) 分析法对语法的要求为：</p>
<blockquote>
<div><p>（1） 起始符号 S 不能位于任何产生式的右边；</p>
<p>（2） 从此语法的起始状态开始生成的所有状态中：</p>
<blockquote>
<div><p>（2.1） 任何一个状态不能同时含有 [ A -&gt; u.aw , c ] 和 [ B -&gt; v. , a ] ；</p>
<p>（2.2） 任何一个状态不能同时含有 [ A -&gt; u. , a ] 和 [ B -&gt; v. , a ] 。</p>
</div></blockquote>
</div></blockquote>
<p>以上的（2.1）将引起 shift/reduce 冲突，（2.2）将引起 reduce/reduce 冲突。一般语言的语法中很少会出现（2.2）的情况，而对于（2.1），在大部分情况下可以通过引入 <strong>优先级</strong> 来解决（见下一节）。</p>
<p>满足以上要求的语法被称为 LR(1) 语法，判断一个语法是否是 LR(1) 语法的方法就是构造其动作表，若构造过程中没有发现冲突，也就是表中的任何元素 M[I, X] 最多只有一个动作，那么此语法就是 LR(1) 语法。</p>
</div>
<div class="section" id="id3">
<h2>12.3 利用符号的优先级来解决冲突<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>大部分情况下， LR(1) 解析过程的 shift/reduce 冲突可以通过引入符号的优先级来解决。具体方法为：</p>
<blockquote>
<div><p>（1） 定义某些符号的优先级以及结合方式；</p>
<p>（2） 当构造 LR(1) 的过程中出现了 shift/reduce 冲突时，即某个状态 I 中同时还有 [ A -&gt; u.aw , c ] 和 [ B -&gt; v. , a ] ，若已定义符号 a 的优先级，且符号串 v 中至少有一个已定义优先级的符号，则可通过以下原则确定 M[I, a] 的动作：</p>
<blockquote>
<div><p>（2.1） 找到 v 中最右边的、已定义优先级的符号（也就是 v 中离 a 最近的一个已定义优先级的符号），假设为 b ；</p>
<p>（2.2） 若 a 的优先级 <strong>低于</strong> b 的优先级，则： M[I, a] = <strong>reduce</strong> B -&gt; v ；</p>
<p>（2.3） 若 a 的优先级 <strong>高于</strong> b 的优先级，则： M[I, a] = <strong>shift</strong> NEXT(I, a) ；</p>
<p>（2.4） 若 a 的优先级 <strong>等于</strong> b 的优先级，则根据 a 和 b 的结合方式：</p>
<blockquote>
<div><p>（2.4.1） 若 a 和 b 都为左结合，则 M[I, a] = <strong>shift</strong> NEXT(I, a) ；</p>
<p>（2.4.2） 若 a 和 b 都为右结合，则 M[I, a] = <strong>reduce</strong> B -&gt; v 。</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>来看一个简单的例子，语法为：</p>
<div class="highlight-text"><div class="highlight"><pre>0) S -&gt; E
1) E -&gt; E + E
2) E -&gt; E * E
3) E -&gt; id

first(S) = first(E) = id
</pre></div>
</div>
<p>所有的状态及转移关系见下：</p>
<div class="highlight-text"><div class="highlight"><pre> I0:                              I1:                            I2:
     Configurations:                  Configurations:                Configurations:
         S -&gt; . E     , $                 S -&gt; E .     , $               E -&gt; id .    , +/*/$
         E -&gt; . E + E , +/*/$             E -&gt; E . + E , +/*/$       Actions:
         E -&gt; . E * E , +/*/$             E -&gt; E . * E , +/*/$           +  : reduce E -&gt; id
         E -&gt; . id    , +/*/$         Actions:                           *  : reduce E -&gt; id
     Actions:                             +  : shift  I3                 $  : reduce E -&gt; id
         E  : goto   I1                   *  : shift  I4
         id : shift  I2                   $  : reduce S -&gt; E


 I3:                              I4:
     Configurations:                  Configurations:
         E -&gt; E + . E , +/*/$             E -&gt; E * . E , +/*/$
         E -&gt; . E + E , +/*/$             E -&gt; . E + E , +/*/$
         E -&gt; . E * E , +/*/$             E -&gt; . E * E , +/*/$
         E -&gt; . id    , +/*/$             E -&gt; . id    , +/*/$
     Actions:                         Actions:
         E  : goto   I5                   E  : goto   I6
         id : shift  I2                   id : shift  I2


 I5:                                           I6:
     Configurations:                               Configurations:
         E -&gt; E + E . , +/*/$                          E -&gt; E * E . , +/*/$
         E -&gt; E . + E , +/*/$                          E -&gt; E . + E , +/*/$
         E -&gt; E . * E , +/*/$                          E -&gt; E . * E , +/*/$
     Actions:                                      Actions:
<span class="hll">         +  : shift  I3 / reduce E -&gt; E + E            +  : shift  I3 / reduce E -&gt; E * E
</span><span class="hll">         *  : shift  I4 / reduce E -&gt; E + E            *  : shift  I4 / reduce E -&gt; E * E
</span>         $  : reduce E -&gt; E + E                        $  : reduce E -&gt; E * E
</pre></div>
</div>
<p>注意状态 I5 和 I6 中都出现了两个 shift/reduce 冲突。以 I5 为例，它同时有以下两条形态：</p>
<div class="highlight-text"><div class="highlight"><pre>1) E -&gt; E + E . , *
2) E -&gt; E . * E , x
</pre></div>
</div>
<p>上面第一条形态的 lookahead 和第二条形态中黑点后面的终结符都是 * ，因此当它遇到一个 * 时，可以执行 shift  I4 ，也可以执行 reduce E -&gt; E + E 。</p>
<p>现在按前面介绍的方法来确定该执行的动作。首先定义符号 * 和 + 的优先级分别为 0 和 1 （数字越小优先级越高），且定义两个符号都是左结合的。</p>
<p>再来看上面第一条形态，其产生式右边的符号串为 E + E ，这个符号串里最右边的、且定义了优先级的符号就是 + ，其优先级为 1 。而此形态的 lookahead （也就是 * ）的优先级为 0 ，高于 + 。因此，选择的动作为 shift 。</p>
<p>再按上面的方法消除其他 shift/reduce 冲突，确定 I5 和 I6 的动作如下（其中方括号内的是被放弃的动作）：</p>
<div class="highlight-text"><div class="highlight"><pre> I5:                                                 I6:
     Configurations:                                     Configurations:
         E -&gt; E + E . , +/*/$                                E -&gt; E * E . , +/*/$
         E -&gt; E . + E , +/*/$                                E -&gt; E . + E , +/*/$
         E -&gt; E . * E , +/*/$                                E -&gt; E . * E , +/*/$
     Actions:                                            Actions:
<span class="hll">         +  : reduce E -&gt; E + E [shift  I3]                 +  : reduce E -&gt; E * E [shift I3]
</span><span class="hll">         *  : shift  I4         [reduce E -&gt; E + E]         *  : reduce E -&gt; E * E [shift I4]
</span>         $  : reduce E -&gt; E + E                             $  : reduce E -&gt; E * E
</pre></div>
</div>
<p>LL(1) 分析法的解析过程中，在挑选产生式的时候只利用下一个读入符号（lookahead）的信息，而 LR(1) 分析法不仅仅是利用下一个读入符号的信息，事实上，它几乎利用了前面读入过的所有的符号的信息。 LR(1) 分析法的解析力量和适用范围远大于 LL(1) 分析法，在引入符号优先级解决常见的 shift/reduce 冲突情况后，它可以解析目前几乎所有的程序语言。</p>
<p>到了这里，可以圆满的回答上一章最后的两个问题了：</p>
<blockquote>
<div><p><strong>如何找出可行的折叠？</strong> 答案：利用状态和形态，当转移到一个含可折叠形态 [ A -&gt; u. , a ] 的状态、且下一个读入符号是 a 时，就可以执行一次可行的折叠了。</p>
<p><strong>有多个可行的折叠怎么办？</strong> 答案： 若采用 LR(1) 分析法，则很少会出现这种情况，且可以比较容易的将语法改写成 LR(1) 语法。</p>
</div></blockquote>
</div>
<div class="section" id="lr-1-lalr-1">
<h2>12.4 优化的 LR(1) 分析法： LALR(1)<a class="headerlink" href="#lr-1-lalr-1" title="Permalink to this headline">¶</a></h2>
<p>从前面的内容可以看出， LR(1) 分析法的构造过程十分复杂，且状态和形态的数量都非常之多，即便是本章第一节的仅仅含 4 个产生式的如此简单的例子，也多达 9 个状态和 27 条形态，如下：</p>
<a class="reference internal image-reference" href="images/lr1_1.png"><img alt="images/lr1_1.png" src="images/lr1_1.png" style="width: 769px; height: 414px;" /></a>
<p><strong>图12.2 状态转移图</strong></p>
<p>上面这个图中， I3 和 I6 几乎是一样的，I4 和 I7 、以及 I8 和 I9 也非常的相似，可以将这样的状态 merge 起来，形成下面这样的状态转移表：</p>
<a class="reference internal image-reference" href="images/lr1_2.png"><img alt="images/lr1_2.png" src="images/lr1_2.png" style="width: 815px; height: 369px;" /></a>
<p><strong>图12.3 状态转移图</strong></p>
<p>可以看出 merge 后的状态总数少了 3 个，可节省动作表的空间，解析速度也有较大的提高。这种将相似状态 merge 起来的分析法称为 LALR(1) 分析法，这是很多编译器所采用的分析方法。具体的 merge 算法比较复杂，本文档就不介绍了，因为 LALR(1) 分析的基本构造流程和解析流程和 LR(1) 分析法是一样的。</p>
<p><strong>第 12 章完</strong></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h4><a href="index.html">首 页</a></h4>
<h4>目 录</h4>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch1_overview.html">第01章 概 述</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch2_TinyC_syntax.html">第02章 源程序 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_Pcode_syntax_a.html">第03章 中间代码 Pcode (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_Pcode_syntax_b.html">第04章 中间代码 Pcode (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5_TinyC_to_Pcode_man.html">第05章 手工编译 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch6_compiler_overview.html">第06章 编译器基本流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch7_lexical_basic.html">第07章 词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch8_flex.html">第08章 用 flex 做词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch9_context_free_grammar.html">第09章 上下文无关语法及分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch10_top_down_parse.html">第10章 自顶向下分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch11_buttom_up_parse_a.html">第11章 自底向上分析 (上)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">第12章 自底向上分析 (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch13_bison.html">第13章 用 bison 做语法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch14_tinyc_frontend.html">第14章 TinyC 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch15_tinyc_backend.html">第15章 TinyC 后端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch16_tinyc_compiler.html">第16章 TinyC 编译器</a></li>
</ul>

  <h4>上一章</h4>
  <p class="topless"><a href="ch11_buttom_up_parse_a.html"
                        title="previous chapter">第11章 自底向上分析 (上)</a></p>
  <h4>下一章</h4>
  <p class="topless"><a href="ch13_bison.html"
                        title="next chapter">第13章 用 bison 做语法分析</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch13_bison.html" title="第13章 用 bison 做语法分析"
             >next</a></li>
        <li class="right" >
          <a href="ch11_buttom_up_parse_a.html" title="第11章 自底向上分析 (上)"
             >previous</a> |</li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, pandolia.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>