第16章 TinyC 编译器
==========================
在第 14 章中，完成了 TinyC 前端，可以将 TinyC 源程序编译成中间代码 Pcode；在第 15 章中，完成了 TinyC 后端，可以将改写后的中间代码 Pcode 翻译、汇编并链接成可执行程序；现在，是时候将二者结合起来形成最终的 TinyC 编译器了。

16.1 改进 TinyC 前端
--------------------------
上一章的 TinyC 后端中，为了降低 Pcode 命令的翻译难度，对 arg / var / ENDFUNC 命令的格式进行了改写，因此需要改进 TinyC 前端，使之能生成能被 TinyC 后端所识别的新格式 Pcode 命令。具体来说，对于下面这段源程序 :download:`test.c </_src/ch16/c01-new-frontend/test.c>` ：

.. literalinclude:: /_src/ch16/c01-new-frontend/test.c
    :language: c

改进后 TinyC 前端需要生成一个 Pcode 文件 :download:`test.pcode </_src/ch16/c01-new-frontend/test.pcode>` ：

.. literalinclude:: /_src/ch16/c01-new-frontend/test.pcode
    :language: nasm
    :emphasize-lines: 2,13,16,17,25

以及一个宏文件 :download:`test.funcmacro </_src/ch16/c01-new-frontend/test.funcmacro>` ：

.. literalinclude:: /_src/ch16/c01-new-frontend/test.funcmacro
    :language: nasm

在第 14 章的 TinyC 前端 1.0 版的 parser.y 的基础上，针对函数定义、参数定义以及变量定义的语句进行改写，改进后的语法分析文件 :download:`parser.y </_src/ch16/c01-new-frontend/parser.y>` ：

.. literalinclude:: /_src/ch16/c01-new-frontend/parser.y
    :language: c

词法分析文件 :download:`scanner.l </_src/ch16/c01-new-frontend/scanner.l>` 不变，和第 14 章的 TinyC 前端 1.0 版的相同。

将以上 :download:`scanner.l </_src/ch16/c01-new-frontend/scanner.l>`, :download:`parser.y </_src/ch16/c01-new-frontend/parser.y>`, :download:`test.c </_src/ch16/c01-new-frontend/test.c>` 三个文件放在同一目录，输入以下命令生成 TinyC 前端 tcc-frontend :

.. code-block:: bash

    flex scanner.l
    bison -vdty parser.y
    gcc -o tcc-frontend lex.yy.c y.tab.c

再输入：

.. code-block:: bash

    ./tcc-frontend test.c

将利用 tcc-frontend 编译 test.c ，生成 Pcode 文件 test.asm 以及宏文件 test.inc 。对比一下前面的 test.pcode 和 test.funcmacro 文件，二者几乎是一模一样的。

16.2 TinyC 编译器
-------------------------------------
现在可以将 TinyC 前端和 TinyC 后端整合起来了。新建一个空的 tinyc 目录，然后 cd 到此目录，之后新建一个 sources 目录，然后将以下 7 个文件放到 sources 目录下:

    :download:`scanner.l </_src/tinyc/sources/scanner.l>`   ， 词法分析文件，和上一节相同；

    :download:`parser.y </_src/tinyc/sources/parser.y>`     ， 语法分析文件，和上一节相同；

    :download:`pysim.py </_src/tinyc/sources/pysim.py>`     ， Pcode 模拟器（ python 程序），和第 4 章相同；

    :download:`tio.c </_src/tinyc/sources/tio.c>`           ， 库函数文件，和上一章最后一节相同；

    :download:`macro.inc </_src/tinyc/sources/macro.inc>`   ， NASM 宏文件，和上一章最后一节相同；

    :download:`tcc </_src/tinyc/sources/tcc>`               ， 编译 TinyC 源程序的脚本文件；

    :download:`pysimulate </_src/tinyc/sources/pysimulate>` ， 模拟运行 Pcode 的脚本文件。

然后在 tinyc 目录下新建一个脚本文件 :download:`build.sh </_src/tinyc/build.sh>` ，内容如下:

.. literalinclude:: /_src/tinyc/build.sh
    :language: bash

在终端输入 **bash build.sh** 将编译生成 TinyC 前端 tcc-frontend 、库文件 libtio.a ，并放在 release 目录下，同时将 macro.inc, pysim.py, pysimulate, tcc 这四个文件拷贝至 release 目录，最后，将 release 目录输出到 PATH 环境变量中。现在，在终端输入 tcc filename.c 就可以利用 TinyC 编译成可执行程序了，而输入 pysimulate filename.asm -da 则可以用 Pcode 模拟器单步调试中间代码 Pcode 了。

让我们来测试一下第一章的示例代码 :download:`test.c </_src/tinyc/test.c>` 吧，将其放在当前目录，然后在终端输入 tcc test.c ，将生成一个 test-c-build 目录，此目录中包含了中间代码文件 test.asm 、函数定义宏文件 test.inc 、目标文件 test.o 、最终的可执行文件 test 。可以输入 test-c-build/test 来运行可执行文件，也可以输入 pysimulate test-c-build/test.asm -da 用 Pcode 模拟器单步调试中间代码。

脚本文件 tcc 首先调用 tcc-frontend 将输入文件（假设为 test.c ）编译为 test.asm 和 test.inc ，然后调用 nasm ，将 test.asm 、 test.inc 和 macro.inc 三个文件一起汇编成 test.o ，最后调用 ld 将 test.o 和 libtio.a 一起链接为最终的可执行程序 test 。 tcc 的内容如下：

.. literalinclude:: /_src/tinyc/sources/tcc
    :language: bash

脚本文件 pysimulate 将调用 python 和 pysim.py 文件，模拟运行输入的 Pcode 文件，其内容如下：

.. literalinclude:: /_src/tinyc/sources/pysimulate
    :language: bash

下面来测试一下第 14 章最后的测试文件包 :download:`samples.zip </_src/ch14/p1.0/samples.zip>` ，将其解包至 samples 目录，再在当前目录新建一个脚本文件 :download:`testall.sh </_src/tinyc/testall.sh>` ，内容如下：

.. literalinclude:: /_src/tinyc/testall.sh
    :language: bash

最后在终端输入 bash testall.sh 将对所有文件进行编译、运行。

至此 TinyC 编译器全部完成。

**第 16 章完**
