<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第07章 词法分析 &mdash; 自己动手写编译器</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="自己动手写编译器" href="index.html" />
    <link rel="next" title="第08章 用 flex 做词法分析" href="ch8_flex.html" />
    <link rel="prev" title="第06章 编译器基本流程" href="ch6_compiler_overview.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch8_flex.html" title="第08章 用 flex 做词法分析"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="ch6_compiler_overview.html" title="第06章 编译器基本流程"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第07章 词法分析<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>7.1 词法分析的基本概念<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>词法分析也称为 <strong>分词</strong> ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 <strong>词</strong> （ <strong>token</strong> 、 <strong>记号</strong> ，后文中将称为 <strong>token</strong> ）。所谓 <strong>token</strong> ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。</p>
<a class="reference internal image-reference" href="images/lexical_analysis.png"><img alt="images/lexical_analysis.png" src="images/lexical_analysis.png" style="width: 585px; height: 190px;" /></a>
<p><strong>图7.1 词法分析示意图</strong></p>
<p>英语中的单词的数量是有限的，程序语言中可用的 token 的类别也是有限的，而且是非常少的。一般来说程序语言中的 token 有：常数（整数、小数、字符、字符串等），操作符（算术操作符、比较操作符、逻辑操作符），分隔符（逗号、分号、括号等），保留字，标识符（变量名、函数名、类名等）等。如：</p>
<blockquote>
<div><ul class="simple">
<li><strong>3</strong> 和 <strong>255</strong> 是整数常数 token</li>
<li><strong>&#8220;Fred&#8221;</strong> 和 <strong>&#8220;wilma&#8221;</strong> 是字符串 token</li>
<li><strong>numTickets</strong> 和 <strong>queue</strong> 是标识符 token</li>
<li><strong>while</strong> 是 T_WHILE token</li>
</ul>
</div></blockquote>
<p>上述的 <strong>3</strong> 、 <strong>&#8220;Fred&#8221;</strong> 和 <strong>while</strong> 等称为 token 的 <strong>字面值</strong> 。有些类别的 token 只有一个字面值，如保留字和分隔符类的 token，其他类别的 token 则有不同字面值，如整数常数 token 。下面是一些典型的 token 及其字面值：</p>
<div class="highlight-text"><div class="highlight"><pre>TOKEN-TYPE              TOKEN-VALUE
-----------------------------------------------
T_IF                    if
T_WHILE                 while
T_ASSIGN                =
T_GREATTHAN             &gt;
T_GREATEQUAL            &gt;=
T_IDENTIFIER            name / numTickets / ...
T_INTEGERCONSTANT       100 / 1 / 12 / ....
T_STRINGCONSTANT        &quot;This is a string&quot; / &quot;hello&quot; / ...
</pre></div>
</div>
<p>编译器中的 token 中一般用一个 struct 来表示：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">T_IF</span><span class="p">,</span> <span class="n">T_WHILE</span><span class="p">,</span> <span class="n">T_ADD</span><span class="p">,</span> <span class="n">T_INTCONSTANT</span><span class="p">,</span> <span class="n">T_STRINGCONSTANT</span><span class="p">,</span> <span class="n">T_IDENTIFIER</span><span class="p">,</span> <span class="p">...</span>
<span class="p">}</span> <span class="n">TokenType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_Token</span> <span class="p">{</span>
    <span class="n">TokenType</span> <span class="n">type</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">stringval</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">intval</span><span class="p">;</span>
        <span class="kt">double</span> <span class="o">*</span><span class="n">doubleval</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TokenRecord</span><span class="p">;</span>
</pre></div>
</div>
<p>词法分析器每扫描到一个完整的 token 后，<strong>立即</strong> 新建一个 TokenRecord ，将此 token 的类型记录在此结构的 <strong>type</strong> 域中，将其字面值记录在 <strong>value</strong> 域中对应的子域内，并将此 TokenRecord 结构传递给下一阶段的语法分析模块使用，然后接着扫描下一个 token 。这样从语法分析模块的角度来看，源程序就变成了一个连续的 <strong>token stream</strong> 了。</p>
<p>分词扫描的方法有直接扫描法和正则表达式匹配扫描法，下面先介绍直接扫描法。</p>
</div>
<div class="section" id="id3">
<h2>7.2 直接扫描法<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>直接扫描法的思路非常简单，每轮扫描，根据第一个字符判断属于哪种类型的 token ，然后采取不同的策略扫描出一个完整的 token ，再接着进行下一轮扫描。例如 TinyC 中，若仅考虑一些简单的情况，按 token 的第一个字符，可以将所有类别的 token 分为以下 7 大类：</p>
<p><strong>（1）A型单字符运算符</strong></p>
<p>包括：+, -, *, /, %， 这种 token 只有一个字符，若本轮扫描的第一个字符为上述字符，则立即返回此字符所代表的 token ，然后移到下一个字符开始下一轮扫描。</p>
<p><strong>（2）B型单字符运算符和双字符运算符</strong></p>
<p>B型单字符运算符包括： &lt; &gt; = ! ，双字符运算符包括： &lt;=, &gt;=, ==, != 。 若本轮扫描的第一个字符为B型单字符运算符时，先查看下一个字符是否是 &#8220;=&#8221; ，如果是，则返回这两个字符代表的 token ，如果否，则返回这个字符代表的 token 。例如，如果扫描到 &#8220;&gt;&#8221; ，则查看下一个字符是否是 &#8220;=&#8221; ，是则返回 T_GREATEEQUAL ，否则返回 T_GREATTHAN 。</p>
<p><strong>（3）关键词和标识符</strong></p>
<p>关键词和标识符都是以字母或下划线开始、且只有字母、下划线或数字组成。若本轮扫描的第一个字符为字母或下划线时，则一直向后扫描，直到遇到第一个既不是字母、也不是下划线或数字的字符，此时一个完整的词就被扫描出来了，然后，查看这个词是不是为关键字，如果是，则返回关键字代表的 token ，如果不是，则返回 T_IDENTIFIER 以及这个词的字面值。</p>
<p><strong>（4）整数常量</strong></p>
<p>整数常量以数字开始，若本轮扫描的第一个字符为数字，则一直向后扫描，直到遇到第一个非数字字符，然后返回 T_INTEGERCONSTANT 和这个数字。</p>
<p><strong>（5）字符串常量</strong></p>
<p>字符串常量以双引号开始和结束，若本轮扫描的第一个字符为双引号，则一直向后扫描，直到遇到第一个双引号，然后返回 T_STRINGCONSTANT 和这个字符串。</p>
<p><strong>（6）空格</strong></p>
<p>若本轮扫描的第一个字符为为空格，则跳过此字符。</p>
<p><strong>（7）注释</strong></p>
<p>注释仅考虑以 <strong>#</strong> 开始的情况，若本轮扫描的第一个字符为 <strong>#</strong>，则直接跳过此行字符流。</p>
<p>以上算法的实现也很简单，<a class="reference download internal" href="downloads/scan.py"><tt class="xref download docutils literal"><span class="pre">scan.py</span></tt></a> 是用 python 按上述思路实现的一个扫描器，它以自己为源文件进行分词。将此文件下载下来，放在终端的当前目录，再在终端输入：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>python scan.py
</pre></div>
</div>
<p>将输出：</p>
<div class="highlight-text"><div class="highlight"><pre>TOKEN TYPE          TOKEN VALUE
--------------------------------------------------
T_identifier        single_char_operators_typeA
T_=                 =
T_{                 {
T_string            &quot;;&quot;
T_,                 ,
T_string            &quot;,&quot;
...
</pre></div>
</div>
<p>该文件中的核心代码是 <strong>scan</strong> 函数，它对一行字符串进行分词，代码如下，读者可以粗略的看看这个函数的代码，基本就是按以上所描述的算法实现的。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">ch</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">isWhiteSpace</span><span class="p">(</span><span class="n">ch</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&quot;#&quot;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">single_char_operators_typeA</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">single_char_operators_typeB</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;=&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">ch</span> <span class="o">+</span> <span class="s">&quot;=&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">isLetter</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&quot;_&quot;</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isLetter</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">isDigit</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;_&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">reservedWords</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="s">&quot;T_identifier&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">isDigit</span><span class="p">(</span><span class="n">ch</span><span class="p">):</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">aDot</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;.&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">aDot</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Too many dot in a number!</span><span class="se">\n\t</span><span class="s">line:&quot;</span><span class="o">+</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">aDot</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">isDigit</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="k">break</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="s">&quot;T_double&quot;</span> <span class="k">if</span> <span class="n">aDot</span> <span class="k">else</span> <span class="s">&quot;T_integer&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">34</span><span class="p">:</span> <span class="c"># 34 means &#39;&quot;&#39;</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">34</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Non-terminated string quote!</span><span class="se">\n\t</span><span class="s">line:&quot;</span><span class="o">+</span><span class="n">line</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="s">&quot;T_string&quot;</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">34</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unknown symbol!</span><span class="se">\n\t</span><span class="s">line:&quot;</span><span class="o">+</span><span class="n">line</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">char:&quot;</span><span class="o">+</span><span class="n">ch</span><span class="p">)</span>
</pre></div>
</div>
<p>可以看出直接扫描法思路简单，代码量非常少，<strong>scan.py</strong> 不过 100 代码。但缺点是速度慢，对标识符类型的 token 需要进行至少 2 次扫描，且需进行字符串查找和比较。而且不容易扩展，只适用于语法简单的语言。目前一般的编译器都是采用基于正则表达式匹配的分词扫描法，以下介绍此方法。</p>
</div>
<div class="section" id="id4">
<h2>7.3 语言、形式语言、正则语言和正则表达式<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>在进一步介绍正则表达式之前，让我们先思考下语言的本质是什么、编译的本质又是什么？编译的输入是程序、输出也是程序，那么程序的本质又是什么？</p>
<p>程序本质上就是一个字符串，而语言呢，可以看成一个由合法程序组成的集合，也就是一个字符串集合。编译是干吗的？一个是判断输入程序是不是源语言中的合法程序，也就是判断一个元素是否属于一个集合，另一个是将源语言中的合法程序转换成目标语言中的合法程序，且两个程序的含义是一致的，也就是将一个集合中的元素映射到另一个集合中的元素上去。</p>
<p>编译原理和语言学的理论基础是集合论，下面用集合论的概念来对语言、程序做一个正式的定义。这些定义对于我们后面的语法分析是至关重要的。</p>
<p>首先介绍几个基本概念：</p>
<blockquote>
<div><p><strong>字母表 Σ 和符号</strong> ： 字母表就是一个有限元素的集合，用 Σ 表示，里面的每个元素称为符号。如： Σ = {0, 1}, Σ = {a, b, ..., z} 。从逻辑的角度来说，只要是一个有限的集合，都可以称为字母表，而不用管里面的元素具体是什么，实际使用时一般用字符的集合。</p>
<p>** Σ 上的句子 sentence/string** ： Σ 上的句子就是一串符号，里面每个符号都属于 Σ ，句子用 s 表示，即 s = θ1 θ2 ... θn , θi ∈ Σ , n ∈ N （此处 N 特指自然数集合），如 abcd, “hello world”, 一个 C 源程序 等都是一个句子。</p>
<p><strong>空句子 ε</strong> ： 空句子就是没有任何符号的句子，用 ε 表示，空句子也是一个句子，就是上面那个式子中 n = 0 的情况。</p>
</div></blockquote>
<p>下面我们来给语言（language）和编译来下一个正式的定义：</p>
<blockquote>
<div><p><strong>语言 L （language）</strong> ： 一个语言就是一个句子集合（a set of sentences），用 L 表示，任何由句子组成的集合都可以被称为一个语言，如：英语就是所有符合英语语法的句子组成的集合，法语就是所有符合法语语法的句子组成的集合， C 语言就是所有能编译成功的 C 源文件的集合，只含一个句子 a 的集合 {a} 是一个语言，集合 {a, ab, abb, ...} 也是一个语言， ...... 。</p>
<p><strong>编译</strong> ：编译就是给定两个句子集合 Ls （源语言）和 Lo （目标语言）以及一个句子 ss ，判断 ss 是否属于 Ls ，以及在 Lo 中寻找出一个句子 so ，其意义和 ss 相同。</p>
</div></blockquote>
<p>下面介绍一种最特别的语言：</p>
<blockquote>
<div><ul class="simple">
<li><strong>形式语言 Σ* （Formal</strong> <strong>language）</strong>：基于 Σ 的形式语言是指 Σ 上的所有句子的集合，用 Σ* 表示，即： Σ* = { s | s = θ1 θ2 ... θn , θi ∈ Σ, n ∈ N }。</li>
</ul>
</div></blockquote>
<p>可以看出所有语言都是形式语言 Σ* 的一个子集。注意：这里说的是形式语言的 <strong>子集</strong> ，并 <strong>不是</strong> 说所有语言都 <strong>是</strong> 形式语言。</p>
<p>下面来介绍我们本章的重点：正则语言。</p>
<p>所谓 <strong>正则语言（Regular</strong> <strong>language）</strong>，是指这样的句子集合：</p>
<blockquote>
<div><p><strong>（1）</strong> 只有一个空句子的集合是一个正则语言，只有一个单符号句子的集合也是一个正则语言。如以下每个集合都是一个正则语言：</p>
<blockquote>
<div><blockquote>
<div>{ε}, {a}, {b}, ..., {z}</div></blockquote>
<p>注意上面每个集合中都只有一个句子，每个句子要么是空句子、要么只有一个字符。另外注意 {ε} 不要和空集搞混了，空集中没有任何元素，{ε} 中有一个空句子元素。</p>
</div></blockquote>
<p><strong>（2）</strong> 如果句子集合 R1 和 R2 是正则语言，则 R1 和 R2 的并集 R 也是一个正则语言，R = R1 ∩ R2。</p>
<p><strong>（3）</strong> 如果句子集合 R1 和 R2 是正则语言，则 R1 和 R2 的连接集合 R 也是一个正则语言。连接集合 R = { s1 s2 | s1 ∈ R1, s2 ∈ R2 } 。</p>
<p><strong>（4）</strong> 如果句子集合 R 是正则语言，则 R 的重复集合 R* 也是一个正则语言，重复集合 R* = { s1 s2 ... sn | si ∈ R , n ∈ N }，此处 n 可以等于 0 ，此时 R* 中只有一个空句子。</p>
</div></blockquote>
<p>一个正则语言就是一个句子集合，那么我们如何表示这个集合？对于集合，我们可以用枚举法来表示，也可以用特性法来表示。对于正则语言，我们用正则表达式来表示。每个正则语言（句子集合），都可以用一个正则表达式来代表它，同样，每个正则表达式，都有一个对应的句子集合。</p>
<p>正则表达式就是按正则语言的构造方式来表示的：</p>
<blockquote>
<div><p>（1） 只有一个空句子的集合的正则表达式为 <strong>ε</strong> ，只有一个单符号句子的集合 {θ} 的正则表达式为 <strong>θ</strong> 。</p>
<p>（2） 如果正则语言 R1 和 R2 的正则表达式为 <strong>r1</strong> 和 <strong>r2</strong> ，那么正则表达式 <strong>r1|r2</strong> 表示 R1 和 R2 的并集。</p>
<p>（3） 如果正则语言 R1 和 R2 的正则表达式为 <strong>r1</strong> 和 <strong>r2</strong> ，那么正则表达式 <strong>r1</strong> <strong>r2</strong> 表示 R1 和 R2 的连接集合。</p>
<p>（4） 如果正则语言 R 的正则表达式为 <strong>r</strong> ， 那么正则表达式 <strong>r*</strong> 表示 R 的重复集合 R* 。</p>
<p>（5） 正则表达式 <strong>(r)</strong> 和 <strong>r</strong> 是等价的。</p>
</div></blockquote>
<p>例如：</p>
<blockquote>
<div>正则表达式 <strong>a</strong> 表示集合 {a}， <strong>b</strong> 表示集合 {b} ， <strong>a|b</strong> 表示集合 {a, b} ， <strong>ab*</strong> 表示集合 {a, ab, abb, abbb, ... } 。</div></blockquote>
<p>以上例子中均用 <strong>粗体字</strong> 来表示正则表达式。</p>
<p>以上构造规则虽然简单，却可以搭建出复杂、表达功能强大的正则表达式，用简短的正则表达式可以表示出一个很大的句子集合。在这里再次强调一下：一个正则表达式就是一个句子集合，简单的正则表达式可以构造出复杂的正则表达式，也就是说简单的句子集合可以构造出复杂的句子集合。</p>
<p>一个句子如果属于一个正则表达式所代表的句子集合，则称这个句子和此正则表达式匹配。</p>
<p>在实际运用中，正则表达式一般都采用一些简写的方式，最常见的有：</p>
<p><strong>（1）特殊字符</strong></p>
<blockquote>
<div>以下 11 个字符：* [ ] ^ $ . | ? * + ( ) 被保留作特殊用途，如果想使用这些字符的字面值，需要在前面加反斜杠 “\” 转义。另外，一些不便书写的字符可以通过在前面加 “\” 转义，如 \n 和 \t 分别表示换行符和制表符。</div></blockquote>
<p><strong>（2）字符集</strong></p>
<blockquote>
<div>如： <strong>[abferx]</strong> ，用方括号括起来的字符，表示匹配这些字符中的其中一个，相当于 <strong>(a|b|f|e|r|x)</strong> 。方括号内的特殊字符不需要转义（ [ ] - ^ 除外），如 <strong>[af({]</strong> 表示 匹配 &#8220;a&#8221;, &#8220;f&#8221;, &#8220;{&#8221;, &#8220;(&#8221; 中的其中一个。方扩号内可以使用 <strong>&#8220;-&#8220;</strong> 来定义一个范围，且可以定义多个范围，如 <strong>[0-9]</strong> 表示匹配单个数字， <strong>[a-zA-Z]</strong> 表示匹配单个字母。</div></blockquote>
<p><strong>（3）取反字符集</strong></p>
<blockquote>
<div>如： <strong>[^abc]</strong> ，在方括号内的第一个字符为 <strong>^</strong> ，表示这是一个取反字符集，表示匹配一个不在方括号内部的字符。</div></blockquote>
<p><strong>（4）*、?和+</strong></p>
<blockquote>
<div><p><strong>*</strong> 表示匹配前面的字符（或者由括号括起来的表达式、方括号括起来的字符集）0次或多次；</p>
<p><strong>?</strong> 表示匹配前面的字符（或者由括号括起来的表达式、方括号括起来的字符集）0次或1次；</p>
<p><strong>+</strong> 表示匹配前面的字符（或者由括号括起来的表达式、方括号括起来的字符集）1次或多次。</p>
</div></blockquote>
<p><strong>（5）&#8221;.&#8221; 通配符</strong></p>
<blockquote>
<div><strong>.</strong> 表示匹配除换行符外的任意字符一次。</div></blockquote>
<p>正则表达式可以用来表示源程序中的 token ，如：</p>
<blockquote>
<div><ul class="simple">
<li>整数   ： <strong>[0-9]+</strong></li>
<li>小数   ： <strong>[0-9]+\.[0-9]*</strong></li>
<li>字符串 ： <strong>\&#8221;[^\&#8221;]*\&#8221;</strong></li>
<li>标识符 ： <strong>[_a-zA-Z][_a-zA-Z0-9]*</strong></li>
<li>关键字 if ： <strong>if</strong></li>
</ul>
</div></blockquote>
<p>下面再简单介绍一下正则表达式的实现原理：有限状态自动机。</p>
</div>
<div class="section" id="fa">
<h2>7.4 有限状态自动机FA<a class="headerlink" href="#fa" title="Permalink to this headline">¶</a></h2>
<p>有限状态自动机（finate automaton）是用来判断字符串（句子）是否和正则表达式匹配的假想机器，它有一个字母表 Σ 、一个状态集合 S ，一个转换函数 T ，当它处于某个状态时，若它读入了一个字符（必须是字母表里的字符），则会根据当前状态和读入的字符自动转换到另一个状态，它有一个初始状态，还有一些所谓的接受状态。</p>
<p>它的工作过程是：首先自动机处于初始状态，之后它开始读入字符串，每读入一个字符，它都根据当前状态和读入字符转换到下一状态，直到字符串结束，若此时自动机处于其接受状态，则表示该字符串被此自动机接受。如下图：</p>
<a class="reference internal image-reference" href="images/dfa.png"><img alt="images/dfa.png" src="images/dfa.png" style="width: 501px; height: 161px;" /></a>
<p><strong>图7.2 典型的有限状态自动机</strong></p>
<p>上图中圆圈表示各种状态，各箭头及签头上的字符表示状态的转换表，自动机只有一个初始状态，用一个不含字符的箭头指向此状态，可以认为此为自动机的入口，自动机可以有一个或多个接受状态，用双圆圈表示。上图中的自动机的字母表为 {a, b}，初始状态为 S1 ，当它读入一个 a 后，就转到状态 S2 ，若读入的是 b ，则转到 S4，然后一个接一个字符的转换其状态，若字符结束时自动机处在其接受状态，则表示此字符串被其接受。经过观察可知，此图中的自动机能接受的字符串为 &#8220;ab&#8221;, &#8220;abb&#8221;, &#8220;abbb&#8221;, ... ，也就是说，此自动机与正则表达式 <strong>ab+</strong> 是等价的。</p>
<p>简单的有限状态自动机可以通过上一小节的 <strong>与、连接和重复</strong> 搭建出复杂的自动机。数学家们已经证明了：任何一个正则表达式都有一个等价的有限状态自动机，任何一个有限状态自动机也有一个等价的正则表达式。</p>
<p>可以看出有限状态自动机的判断速度是非常快的，它只要求对字符串扫描一遍就可以了，显然比前面介绍的直接扫描法要快多了。</p>
<p>总而言之，正则表达式的匹配判断可以通过构造有限状态自动机来进行，以上仅介绍了构造有限状态自动机的大体思路：先构造基本的自动机，再根据正则表达式的结构搭建出复杂的自动机。构造有限状态自动机的具体算法十分复杂，本站不再深入介绍了，还是借用前人已经做好的工具吧，下一章中，将介绍如何使用 flex 来进行基于正则匹配的词法分析。</p>
<p><strong>第 7 章完</strong></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h4><a href="index.html">首 页</a></h4>
<h4>目 录</h4>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch1_overview.html">第01章 概 述</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch2_TinyC_syntax.html">第02章 源程序 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_Pcode_syntax_a.html">第03章 中间代码 Pcode (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_Pcode_syntax_b.html">第04章 中间代码 Pcode (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5_TinyC_to_Pcode_man.html">第05章 手工编译 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch6_compiler_overview.html">第06章 编译器基本流程</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">第07章 词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch8_flex.html">第08章 用 flex 做词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch9_context_free_grammar.html">第09章 上下文无关语法及分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch10_top_down_parse.html">第10章 自顶向下分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch11_buttom_up_parse_a.html">第11章 自底向上分析 (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch12_buttom_up_parse_b.html">第12章 自底向上分析 (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch13_bison.html">第13章 用 bison 做语法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch14_tinyc_frontend.html">第14章 TinyC 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch15_tinyc_backend.html">第15章 TinyC 后端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch16_tinyc_compiler.html">第16章 TinyC 编译器</a></li>
</ul>

  <h4>上一章</h4>
  <p class="topless"><a href="ch6_compiler_overview.html"
                        title="previous chapter">第06章 编译器基本流程</a></p>
  <h4>下一章</h4>
  <p class="topless"><a href="ch8_flex.html"
                        title="next chapter">第08章 用 flex 做词法分析</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch8_flex.html" title="第08章 用 flex 做词法分析"
             >next</a></li>
        <li class="right" >
          <a href="ch6_compiler_overview.html" title="第06章 编译器基本流程"
             >previous</a> |</li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, pandolia.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>