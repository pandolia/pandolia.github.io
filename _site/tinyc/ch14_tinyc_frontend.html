<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第14章 TinyC 前端 &mdash; 自己动手写编译器</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="自己动手写编译器" href="index.html" />
    <link rel="next" title="第15章 TinyC 后端" href="ch15_tinyc_backend.html" />
    <link rel="prev" title="第13章 用 bison 做语法分析" href="ch13_bison.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch15_tinyc_backend.html" title="第15章 TinyC 后端"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="ch13_bison.html" title="第13章 用 bison 做语法分析"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tinyc">
<h1>第14章 TinyC 前端<a class="headerlink" href="#tinyc" title="Permalink to this headline">¶</a></h1>
<p>上一章介绍了 bison 中一些常用功能的使用方法，bison 是一个非常强大的语法分析工具，读者还可以阅读一下 bison 的文档进行更深入的学习。本章介绍如何利用 flex 和 bison 实现 TinyC 编译器的前端，建议读者先复习一下 <strong>第 5 章 手工编译 TinyC</strong> ，再来看本章的代码。</p>
<div class="section" id="id1">
<h2>14.1 第 0.1 版<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>首先对上一章的雏形版本稍微升级一下，增加变量声明和 print 语句，一共有 5 个文件：</p>
<p>词法分析文件： <a class="reference download internal" href="downloads/scanner1.l"><tt class="xref download docutils literal"><span class="pre">scanner.l</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre>%{
#define YYSTYPE char *
#include &quot;y.tab.h&quot;
int cur_line = 1;
void yyerror(const char *msg);
void unrecognized_char(char c);
#define _DUPTEXT {yylval = strdup(yytext);}
%}

/* note \042 is &#39;&quot;&#39; */

OPERATOR        ([-/+*()=,;])
INTEGER         ([0-9]+)
STRING          (\042[^\042\n]*\042)
IDENTIFIER      ([_a-zA-Z][_a-zA-Z0-9]*)
WHITESPACE      ([ \t]*)

%%
{OPERATOR}      { return yytext[0]; }
&quot;int&quot;           { return T_Int; }
&quot;print&quot;         { return T_Print; }

{INTEGER}       { _DUPTEXT; return T_IntConstant; }
{STRING}        { _DUPTEXT; return T_StringConstant; }
{IDENTIFIER}    { _DUPTEXT; return T_Identifier; }

{WHITESPACE}    { /* ignore every whitespace */ }
\n              { cur_line++; }
.               { unrecognized_char(yytext[0]); }
%%

int yywrap(void) { 
    return 1;
}

void unrecognized_char(char c) {
    char buf[32] = &quot;Unrecognized character: ?&quot;;
    buf[24] = c;
    yyerror(buf);
}

void yyerror(const char *msg) {
    printf(&quot;Error at line %d:\n\t%s\n&quot;, cur_line, msg);
    exit(-1);
}
</pre></div>
</div>
<p>语法分析文件： <a class="reference download internal" href="downloads/parser1.y"><tt class="xref download docutils literal"><span class="pre">parser.y</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre>%{
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void yyerror(const char*);
#define YYSTYPE char *
%}

%token T_StringConstant T_IntConstant T_Identifier T_Int T_Print

%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;
%right U_neg

%%

S:   
    Stmt                        { /* empty */ }
|   S Stmt                      { /* empty */ }
;

Stmt:
    VarDecl &#39;;&#39;                 { printf(&quot;\n\n&quot;); }
|   Assign                      { /* empty */ }
|   Print                       { /* empty */ }
;

VarDecl:
    T_Int T_Identifier          { printf(&quot;var %s&quot;, $2); }
|   VarDecl &#39;,&#39; T_Identifier    { printf(&quot;, %s&quot;, $3); }
;

Assign:
    T_Identifier &#39;=&#39; E &#39;;&#39;      { printf(&quot;pop %s\n\n&quot;, $1); }
;

Print:
    T_Print &#39;(&#39; T_StringConstant Actuals &#39;)&#39; &#39;;&#39;
                                { printf(&quot;print %s\n\n&quot;, $3); }
;

Actuals:
    /* empty */                 { /* empty */ }
|   Actuals &#39;,&#39; E               { /* empty */ }
;

E:
    E &#39;+&#39; E                     { printf(&quot;add\n&quot;); }
|   E &#39;-&#39; E                     { printf(&quot;sub\n&quot;); }
|   E &#39;*&#39; E                     { printf(&quot;mul\n&quot;); }
|   E &#39;/&#39; E                     { printf(&quot;div\n&quot;); }
|   &#39;-&#39; E %prec U_neg           { printf(&quot;neg\n&quot;); }
|   T_IntConstant               { printf(&quot;push %s\n&quot;, $1); }
|   T_Identifier                { printf(&quot;push %s\n&quot;, $1); }
|   &#39;(&#39; E &#39;)&#39;                   { /* empty */ }
;

%%

int main() {
    return yyparse();
}
</pre></div>
</div>
<p>makefile 文件： <a class="reference download internal" href="downloads/makefile1"><tt class="xref download docutils literal"><span class="pre">makefile</span></tt></a></p>
<div class="highlight-makefile"><div class="highlight"><pre><span class="nv">OUT</span>      <span class="o">=</span> tcc
<span class="nv">TESTFILE</span> <span class="o">=</span> test.c
<span class="nv">SCANNER</span>  <span class="o">=</span> scanner.l
<span class="nv">PARSER</span>   <span class="o">=</span> parser.y

<span class="nv">CC</span>       <span class="o">=</span> gcc
<span class="nv">OBJ</span>      <span class="o">=</span> lex.yy.o y.tab.o
<span class="nv">TESTOUT</span>  <span class="o">=</span> <span class="k">$(</span>basename <span class="k">$(</span>TESTFILE<span class="k">))</span>.asm
<span class="nv">OUTFILES</span> <span class="o">=</span> lex.yy.c y.tab.c y.tab.h y.output <span class="k">$(</span>OUT<span class="k">)</span>

<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">build</span> <span class="n">test</span> <span class="n">simulate</span> <span class="n">clean</span>

<span class="nf">build</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OUT</span><span class="k">)</span>

<span class="nf">test</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TESTOUT</span><span class="k">)</span>

<span class="nf">simulate</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TESTOUT</span><span class="k">)</span>
	python pysim.py <span class="nv">$&lt;</span>

<span class="nf">clean</span><span class="o">:</span>
	rm -f *.o <span class="k">$(</span>OUTFILES<span class="k">)</span>

<span class="nf">$(TESTOUT)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">TESTFILE</span><span class="k">)</span> <span class="k">$(</span><span class="nv">OUT</span><span class="k">)</span>
	./<span class="k">$(</span>OUT<span class="k">)</span> &lt; <span class="nv">$&lt;</span> &gt; <span class="nv">$@</span>

<span class="nf">$(OUT)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJ</span><span class="k">)</span>
	<span class="k">$(</span>CC<span class="k">)</span> -o <span class="k">$(</span>OUT<span class="k">)</span> <span class="k">$(</span>OBJ<span class="k">)</span>

<span class="nf">lex.yy.c</span><span class="o">:</span> <span class="k">$(</span><span class="nv">SCANNER</span><span class="k">)</span> <span class="n">y</span>.<span class="n">tab</span>.<span class="n">c</span>
	flex <span class="nv">$&lt;</span>

<span class="nf">y.tab.c</span><span class="o">:</span> <span class="k">$(</span><span class="nv">PARSER</span><span class="k">)</span>
	bison -vdty <span class="nv">$&lt;</span>
</pre></div>
</div>
<p>测试文件： <a class="reference download internal" href="downloads/test1.c"><tt class="xref download docutils literal"><span class="pre">test.c</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">);</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>

<span class="n">print</span><span class="p">(</span><span class="s">&quot;a = %d, b = %d, c = %d, d = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>Pcode 模拟器： <a class="reference download internal" href="downloads/pysim.py"><tt class="xref download docutils literal"><span class="pre">pysim.py</span></tt></a> ，已经在第 4 章中介绍了。</p>
<p>这个版本在上一章的雏形版本的基础上，进行了以下扩充：</p>
<blockquote>
<div><p>词法分析文件中：</p>
<blockquote>
<div><p>增加了 T_StringConstant, T_Int, T_Print 类型的 token ，以及相应的正则表达式；</p>
<p>增加了一个 _DUPTEXT 宏，表示 yylval = strdup(yytext) 。</p>
</div></blockquote>
<p>语法分析文件中：</p>
<blockquote>
<div>增加了 VarDecl 和 Print 两个非终结符以及相应的产生式。</div></blockquote>
</div></blockquote>
<p>本版本的语法分析文件中，同样要注意源文件的解析过程中各产生式的折叠顺序以及相应的 Pcode 生成顺序。</p>
<p>makefile 里面是编译和测试这个程序的命令，在终端输入 make 后，将编译生成可执行文件 tcc ，然后输入 make test ，（相当于 &#8221;./tcc &lt; test.c &gt; test.asm&#8221; ） ，将输出 test.asm 文件，内容如下：</p>
<div class="highlight-text"><div class="highlight"><pre>var a, b, c, d

push 1
push 2
push 2
push 2
add
mul
add
pop a

push 5
pop c

push 10
pop d

push c
push d
add
pop b

push a
push b
push c
push d
print &quot;a = %d, b = %d, c = %d, d = %d&quot;
</pre></div>
</div>
<p>可以看出 test.c 文件里的所有语句都被转换成相应的 Pcode 了。再用 Pcode 模拟器运行一下这些 Pcode ，在终端输入 &#8220;make simulate&#8221; （相当于 &#8220;python pysim.py test.asm&#8221; ） ，将输出：</p>
<div class="highlight-text"><div class="highlight"><pre>a = 9, b = 5, c = 10, d = 15
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>14.2 第 0.5 版<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在第 0.1 版的基础上升级，增加函数定义及调用语句、注释等功能，一共有 5 个文件：</p>
<p>词法分析文件： <a class="reference download internal" href="downloads/scanner2.l"><tt class="xref download docutils literal"><span class="pre">scanner.l</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre>%{
#define YYSTYPE char *
#include &quot;y.tab.h&quot;
int cur_line = 1;
void yyerror(const char *msg);
void unrecognized_char(char c);
void unterminate_string();
#define _DUPTEXT {yylval = strdup(yytext);}
%}

/* note \042 is &#39;&quot;&#39; */
WHITESPACE          ([ \t\r\a]+)
SINGLE_COMMENT1     (&quot;//&quot;[^\n]*)
SINGLE_COMMENT2     (&quot;#&quot;[^\n]*)
OPERATOR            ([+*-/%=,;!&lt;&gt;(){}])
INTEGER             ([0-9]+)
IDENTIFIER          ([_a-zA-Z][_a-zA-Z0-9]*)
UNTERM_STRING       (\042[^\042\n]*)
STRING              (\042[^\042\n]*\042)

%%

\n                  { cur_line++; }
{WHITESPACE}        { /* ignore every whitespace */ }
{SINGLE_COMMENT1}   { /* skip for single line comment */    }
{SINGLE_COMMENT2}   { /* skip for single line comment */    }

{OPERATOR}          { return yytext[0]; }
&quot;int&quot;               { return T_Int; }
&quot;void&quot;              { return T_Void; }
&quot;return&quot;            { return T_Return; }
&quot;print&quot;             { return T_Print; }

{INTEGER}           { _DUPTEXT return T_IntConstant; }
{STRING}            { _DUPTEXT return T_StringConstant; }
{IDENTIFIER}        { _DUPTEXT return T_Identifier; }

{UNTERM_STRING}     { unterminate_string(); }
.                   { unrecognized_char(yytext[0]); }

%%

int yywrap(void) { 
    return 1;
}

void unrecognized_char(char c) {
    char buf[32] = &quot;Unrecognized character: ?&quot;;
    buf[24] = c;
    yyerror(buf);
}

void unterminate_string() {
    yyerror(&quot;Unterminate string constant&quot;);
}

void yyerror(const char *msg) {
    fprintf(stderr, &quot;Error at line %d:\n\t%s\n&quot;, cur_line, msg);
    exit(-1);
}
</pre></div>
</div>
<p>语法分析文件： <a class="reference download internal" href="downloads/parser2.y"><tt class="xref download docutils literal"><span class="pre">parser.y</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre>%{
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void yyerror(const char*);
#define YYSTYPE char *
%}

%token T_Int T_Void T_Return T_Print T_IntConstant
%token T_StringConstant T_Identifier

%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;
%right U_neg

%%

Program:
    /* empty */             { /* empty */ }
|   Program FuncDecl        { /* empty */ }
;

FuncDecl:
    RetType FuncName &#39;(&#39; Args &#39;)&#39; &#39;{&#39; VarDecls Stmts &#39;}&#39;
                            { printf(&quot;ENDFUNC\n\n&quot;); }
;

RetType:
    T_Int                   { /* empty */ }
|   T_Void                  { /* empty */ }
;

FuncName:
    T_Identifier            { printf(&quot;FUNC @%s:\n&quot;, $1); }
;

Args:
    /* empty */             { /* empty */ }
|   _Args                   { printf(&quot;\n\n&quot;); }
;

_Args:
    T_Int T_Identifier      { printf(&quot;arg %s&quot;, $2); }
|   _Args &#39;,&#39; T_Int T_Identifier
                            { printf(&quot;, %s&quot;, $4); }
;

VarDecls:
    /* empty */             { /* empty */ }
|   VarDecls VarDecl &#39;;&#39;    { printf(&quot;\n\n&quot;); }
;

VarDecl:
    T_Int T_Identifier      { printf(&quot;var %s&quot;, $2); }
|   VarDecl &#39;,&#39; T_Identifier
                            { printf(&quot;, %s&quot;, $3); }
;

Stmts:
    /* empty */             { /* empty */ }
|   Stmts Stmt              { /* empty */ }
;

Stmt:
    AssignStmt              { /* empty */ }
|   PrintStmt               { /* empty */ }
|   CallStmt                { /* empty */ }
|   ReturnStmt              { /* empty */ }
;

AssignStmt:
    T_Identifier &#39;=&#39; Expr &#39;;&#39;
                            { printf(&quot;pop %s\n\n&quot;, $1); }
;

PrintStmt:
    T_Print &#39;(&#39; T_StringConstant PActuals &#39;)&#39; &#39;;&#39;
                            { printf(&quot;print %s\n\n&quot;, $3); }
;

PActuals:
    /* empty */             { /* empty */ }
|   PActuals &#39;,&#39; Expr       { /* empty */ }
;

CallStmt:
    CallExpr &#39;;&#39;            { printf(&quot;pop\n\n&quot;); }
;

CallExpr:
    T_Identifier &#39;(&#39; Actuals &#39;)&#39;
                            { printf(&quot;$%s\n&quot;, $1); }
;

Actuals:
    /* empty */             { /* empty */ }
|   Expr PActuals           { /* empty */ }
;

ReturnStmt:
    T_Return Expr &#39;;&#39;       { printf(&quot;ret ~\n\n&quot;); }
|   T_Return &#39;;&#39;            { printf(&quot;ret\n\n&quot;); }
;

Expr:
    Expr &#39;+&#39; Expr           { printf(&quot;add\n&quot;); }
|   Expr &#39;-&#39; Expr           { printf(&quot;sub\n&quot;); }
|   Expr &#39;*&#39; Expr           { printf(&quot;mul\n&quot;); }
|   Expr &#39;/&#39; Expr           { printf(&quot;div\n&quot;); }
|   &#39;-&#39; Expr %prec U_neg    { printf(&quot;neg\n&quot;); }
|   T_IntConstant           { printf(&quot;push %s\n&quot;, $1); }
|   T_Identifier            { printf(&quot;push %s\n&quot;, $1); }
|   CallExpr                { /* empty */ }
|   &#39;(&#39; Expr &#39;)&#39;            { /* empty */ }
;

%%

int main() {
    return yyparse();
}
</pre></div>
</div>
<p>makefile 文件： <a class="reference download internal" href="downloads/makefile2"><tt class="xref download docutils literal"><span class="pre">makefile</span></tt></a>， 和第 0.1 版本中唯一不同的只有 &#8220;python pysim.py $&lt; -a&#8221; 那一行有一个 <strong>&#8220;-a&#8221;</strong> 。</p>
<p>测试文件： <a class="reference download internal" href="downloads/test2.c"><tt class="xref download docutils literal"><span class="pre">test.c</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// tiny c test file</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>

    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;c = %d, d = %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;a = sum(c, d) = %d, b = sum(a, d) = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pcode 模拟器： <a class="reference download internal" href="downloads/pysim1.py"><tt class="xref download docutils literal"><span class="pre">pysim.py</span></tt></a> ，已经在第 4 章中介绍了。</p>
<p>这个版本在第 0.1 版本的基础上，进行了以下扩充：</p>
<blockquote>
<div><p>词法分析文件中：</p>
<blockquote>
<div><p>增加了 T_Void 和 T_Return 类型的 token ，以及相应的正则表达式；</p>
<p>增加了单行注释的过滤功能；增加了一个错误处理函数： unterminate_string ，该函数可以检查出未结束的字符串（不匹配的双引号）的词法错误。</p>
</div></blockquote>
<p>语法分析文件中：</p>
<blockquote>
<div>增加了 Program, FuncDecl, Args, Actuals, CallExpr 等非终结符以及相应的产生式，请注意各产生式的折叠顺序以及相应的 Pcode 生成顺序。</div></blockquote>
</div></blockquote>
<p>makefile 里面是编译和测试这个程序的命令，内容和第 0.1 版的基本一样，但增加了一些变量以便于扩充，另外，&#8221;python pysim.py...&#8221; 那一行最后的命令行参数是 <strong>&#8220;-a&#8221;</strong> 。在终端输入 make 后，将编译生成可执行文件 tcc ，然后输入 make test ，（相当于 &#8221;./tcc &lt; test.c &gt; test.asm&#8221; ） ，将输出 test.asm 文件，内容如下：</p>
<div class="highlight-text"><div class="highlight"><pre>FUNC @main:
var a, b, c, d

push 2
pop c

push c
push 2
mul
pop d

push c
push d
$sum
pop a

push a
push d
$sum
pop b

push c
push d
print &quot;c = %d, d = %d&quot;

push a
push b
print &quot;a = sum(c, d) = %d, b = sum(a, d) = %d&quot;

push 0
ret ~

ENDFUNC

FUNC @sum:
arg a, b

var c, d

push a
push b
add
ret ~

ENDFUNC
</pre></div>
</div>
<p>可以看出 test.c 文件里的所有语句都被转换成相应的 Pcode 了。再用 Pcode 模拟器运行一下这些 Pcode ，在终端输入 &#8220;make simulate&#8221; （相当于 &#8220;python pysim.py test.asm -a&#8221; ，注意最后有一个 <strong>&#8220;-a&#8221;</strong> ） ，将输出：</p>
<div class="highlight-text"><div class="highlight"><pre>c = 2, d = 4
a = sum(c, d) = 6, b = sum(a, d) = 10
</pre></div>
</div>
<p>有兴趣的读者还可以使用 &#8220;python pysim.py test.asm -da&#8221; 来逐句运行一下这个 Pcode 文件。</p>
</div>
<div class="section" id="id3">
<h2>14.3 第 1.0 版<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>继续在第 0.5 版的基础上升级，增加 if 和 while 语句、比较运算符和逻辑运算符以及 readint 命令，就形成了完整的 TinyC 前端。一共有 7 个文件：</p>
<p>词法分析文件： <a class="reference download internal" href="downloads/scanner3.l"><tt class="xref download docutils literal"><span class="pre">scanner.l</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre>%{
#define YYSTYPE char *
#include &quot;y.tab.h&quot;
int cur_line = 1;
void yyerror(const char *msg);
void unrecognized_char(char c);
void unterminate_string();
#define _DUPTEXT {yylval = strdup(yytext);}
%}

/* note \042 is &#39;&quot;&#39; */
WHITESPACE          ([ \t\r\a]+)
SINGLE_COMMENT1     (&quot;//&quot;[^\n]*)
SINGLE_COMMENT2     (&quot;#&quot;[^\n]*)
OPERATOR            ([+*-/%=,;!&lt;&gt;(){}])
INTEGER             ([0-9]+)
IDENTIFIER          ([_a-zA-Z][_a-zA-Z0-9]*)
UNTERM_STRING       (\042[^\042\n]*)
STRING              (\042[^\042\n]*\042)

%%

\n                  { cur_line++; }
{WHITESPACE}        { /* ignore every whitespace */ }
{SINGLE_COMMENT1}   { /* skip for single line comment */    }
{SINGLE_COMMENT2}   { /* skip for single line comment */    }

{OPERATOR}          { return yytext[0]; }
&quot;int&quot;               { return T_Int; }
&quot;void&quot;              { return T_Void; }
&quot;return&quot;            { return T_Return; }
&quot;print&quot;             { return T_Print; }
<span class="hll">&quot;readint&quot;           { return T_ReadInt; }
</span><span class="hll">&quot;while&quot;             { return T_While; }
</span><span class="hll">&quot;if&quot;                { return T_If; }
</span><span class="hll">&quot;else&quot;              { return T_Else; }
</span><span class="hll">&quot;break&quot;             { return T_Break; }
</span><span class="hll">&quot;continue&quot;          { return T_Continue; }
</span><span class="hll">&quot;&lt;=&quot;                { return T_Le; }
</span><span class="hll">&quot;&gt;=&quot;                { return T_Ge; }
</span><span class="hll">&quot;==&quot;                { return T_Eq; }
</span><span class="hll">&quot;!=&quot;                { return T_Ne; }
</span><span class="hll">&quot;&amp;&amp;&quot;                { return T_And; }
</span><span class="hll">&quot;||&quot;                { return T_Or; }
</span>
{INTEGER}           { _DUPTEXT return T_IntConstant; }
{STRING}            { _DUPTEXT return T_StringConstant; }
{IDENTIFIER}        { _DUPTEXT return T_Identifier; }

{UNTERM_STRING}     { unterminate_string(); }
.                   { unrecognized_char(yytext[0]); }

%%

int yywrap(void) { 
    return 1;
}

void unrecognized_char(char c) {
    char buf[32] = &quot;Unrecognized character: ?&quot;;
    buf[24] = c;
    yyerror(buf);
}

void unterminate_string() {
    yyerror(&quot;Unterminate string constant&quot;);
}

void yyerror(const char *msg) {
    fprintf(stderr, &quot;Error at line %d:\n\t%s\n&quot;, cur_line, msg);
    exit(-1);
}
</pre></div>
</div>
<p>语法分析文件： <a class="reference download internal" href="downloads/parser3.y"><tt class="xref download docutils literal"><span class="pre">parser.y</span></tt></a></p>
<div class="highlight-c"><div class="highlight"><pre>%{
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void yyerror(const char*);
#define YYSTYPE char *

<span class="hll">int ii = 0, itop = -1, istack[100];
</span><span class="hll">int ww = 0, wtop = -1, wstack[100];
</span><span class="hll">
</span><span class="hll">#define _BEG_IF     {istack[++itop] = ++ii;}
</span><span class="hll">#define _END_IF     {itop--;}
</span><span class="hll">#define _i          (istack[itop])
</span><span class="hll">
</span><span class="hll">#define _BEG_WHILE  {wstack[++wtop] = ++ww;}
</span><span class="hll">#define _END_WHILE  {wtop--;}
</span><span class="hll">#define _w          (wstack[wtop])
</span>
%}

<span class="hll">%token T_Int T_Void T_Return T_Print T_ReadInt T_While
</span><span class="hll">%token T_If T_Else T_Break T_Continue T_Le T_Ge T_Eq T_Ne
</span><span class="hll">%token T_And T_Or T_IntConstant T_StringConstant T_Identifier
</span><span class="hll">
</span><span class="hll">%left &#39;=&#39;
</span><span class="hll">%left T_Or
</span><span class="hll">%left T_And
</span><span class="hll">%left T_Eq T_Ne
</span><span class="hll">%left &#39;&lt;&#39; &#39;&gt;&#39; T_Le T_Ge
</span><span class="hll">%left &#39;+&#39; &#39;-&#39;
</span><span class="hll">%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
</span><span class="hll">%left &#39;!&#39;
</span>
%%

Program:
    /* empty */             { /* empty */ }
|   Program FuncDecl        { /* empty */ }
;

FuncDecl:
    RetType FuncName &#39;(&#39; Args &#39;)&#39; &#39;{&#39; VarDecls Stmts &#39;}&#39;
                            { printf(&quot;ENDFUNC\n\n&quot;); }
;

RetType:
    T_Int                   { /* empty */ }
|   T_Void                  { /* empty */ }
;

FuncName:
    T_Identifier            { printf(&quot;FUNC @%s:\n&quot;, $1); }
;

Args:
    /* empty */             { /* empty */ }
|   _Args                   { printf(&quot;\n\n&quot;); }
;

_Args:
    T_Int T_Identifier      { printf(&quot;\targ %s&quot;, $2); }
|   _Args &#39;,&#39; T_Int T_Identifier
                            { printf(&quot;, %s&quot;, $4); }
;

VarDecls:
    /* empty */             { /* empty */ }
|   VarDecls VarDecl &#39;;&#39;    { printf(&quot;\n\n&quot;); }
;

VarDecl:
    T_Int T_Identifier      { printf(&quot;\tvar %s&quot;, $2); }
|   VarDecl &#39;,&#39; T_Identifier
                            { printf(&quot;, %s&quot;, $3); }
;

Stmts:
    /* empty */             { /* empty */ }
|   Stmts Stmt              { /* empty */ }
;

Stmt:
    AssignStmt              { /* empty */ }
|   PrintStmt               { /* empty */ }
|   CallStmt                { /* empty */ }
|   ReturnStmt              { /* empty */ }
|   IfStmt                  { /* empty */ }
|   WhileStmt               { /* empty */ }
|   BreakStmt               { /* empty */ }
|   ContinueStmt            { /* empty */ }
;

AssignStmt:
    T_Identifier &#39;=&#39; Expr &#39;;&#39;
                            { printf(&quot;\tpop %s\n\n&quot;, $1); }
;

PrintStmt:
    T_Print &#39;(&#39; T_StringConstant PActuals &#39;)&#39; &#39;;&#39;
                            { printf(&quot;\tprint %s\n\n&quot;, $3); }
;

PActuals:
    /* empty */             { /* empty */ }
|   PActuals &#39;,&#39; Expr       { /* empty */ }
;

CallStmt:
    CallExpr &#39;;&#39;            { printf(&quot;\tpop\n\n&quot;); }
;

CallExpr:
    T_Identifier &#39;(&#39; Actuals &#39;)&#39;
                            { printf(&quot;\t$%s\n&quot;, $1); }
;

Actuals:
    /* empty */             { /* empty */ }
|   Expr PActuals           { /* empty */ }
;

ReturnStmt:
    T_Return Expr &#39;;&#39;       { printf(&quot;\tret ~\n\n&quot;); }
|   T_Return &#39;;&#39;            { printf(&quot;\tret\n\n&quot;); }
;

<span class="hll">IfStmt:
</span><span class="hll">    If TestExpr Then StmtsBlock EndThen EndIf
</span><span class="hll">                            { /* empty */ }
</span><span class="hll">|   If TestExpr Then StmtsBlock EndThen Else StmtsBlock EndIf
</span><span class="hll">                            { /* empty */ }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">TestExpr:
</span><span class="hll">    &#39;(&#39; Expr &#39;)&#39;            { /* empty */ }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">StmtsBlock:
</span><span class="hll">    &#39;{&#39; Stmts &#39;}&#39;           { /* empty */ }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">If:
</span><span class="hll">    T_If            { _BEG_IF; printf(&quot;_begIf_%d:\n&quot;, _i); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">Then:
</span><span class="hll">    /* empty */     { printf(&quot;\tjz _elIf_%d\n&quot;, _i); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">EndThen:
</span><span class="hll">    /* empty */     { printf(&quot;\tjmp _endIf_%d\n_elIf_%d:\n&quot;, _i, _i); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">Else:
</span><span class="hll">    T_Else          { /* empty */ }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">EndIf:
</span><span class="hll">    /* empty */     { printf(&quot;_endIf_%d:\n\n&quot;, _i); _END_IF; }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">WhileStmt:
</span><span class="hll">    While TestExpr Do StmtsBlock EndWhile
</span><span class="hll">                    { /* empty */ }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">While:
</span><span class="hll">    T_While         { _BEG_WHILE; printf(&quot;_begWhile_%d:\n&quot;, _w); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">Do:
</span><span class="hll">    /* empty */     { printf(&quot;\tjz _endWhile_%d\n&quot;, _w); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">EndWhile:
</span><span class="hll">    /* empty */     { printf(&quot;\tjmp _begWhile_%d\n_endWhile_%d:\n\n&quot;, 
</span><span class="hll">                                _w, _w); _END_WHILE; }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">BreakStmt:
</span><span class="hll">    T_Break &#39;;&#39;     { printf(&quot;\tjmp _endWhile_%d\n&quot;, _w); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">ContinueStmt:
</span><span class="hll">    T_Continue &#39;;&#39;  { printf(&quot;\tjmp _begWhile_%d\n&quot;, _w); }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">Expr:
</span><span class="hll">    Expr &#39;+&#39; Expr           { printf(&quot;\tadd\n&quot;); }
</span><span class="hll">|   Expr &#39;-&#39; Expr           { printf(&quot;\tsub\n&quot;); }
</span><span class="hll">|   Expr &#39;*&#39; Expr           { printf(&quot;\tmul\n&quot;); }
</span><span class="hll">|   Expr &#39;/&#39; Expr           { printf(&quot;\tdiv\n&quot;); }
</span><span class="hll">|   Expr &#39;%&#39; Expr           { printf(&quot;\tmod\n&quot;); }
</span><span class="hll">|   Expr &#39;&gt;&#39; Expr           { printf(&quot;\tcmpgt\n&quot;); }
</span><span class="hll">|   Expr &#39;&lt;&#39; Expr           { printf(&quot;\tcmplt\n&quot;); }
</span><span class="hll">|   Expr T_Ge Expr          { printf(&quot;\tcmpge\n&quot;); }
</span><span class="hll">|   Expr T_Le Expr          { printf(&quot;\tcmple\n&quot;); }
</span><span class="hll">|   Expr T_Eq Expr          { printf(&quot;\tcmpeq\n&quot;); }
</span><span class="hll">|   Expr T_Ne Expr          { printf(&quot;\tcmpne\n&quot;); }
</span><span class="hll">|   Expr T_Or Expr          { printf(&quot;\tor\n&quot;); }
</span><span class="hll">|   Expr T_And Expr         { printf(&quot;\tand\n&quot;); }
</span><span class="hll">|   &#39;-&#39; Expr %prec &#39;!&#39;      { printf(&quot;\tneg\n&quot;); }
</span><span class="hll">|   &#39;!&#39; Expr                { printf(&quot;\tnot\n&quot;); }
</span><span class="hll">|   T_IntConstant           { printf(&quot;\tpush %s\n&quot;, $1); }
</span><span class="hll">|   T_Identifier            { printf(&quot;\tpush %s\n&quot;, $1); }
</span><span class="hll">|   ReadInt                 { /* empty */ }
</span><span class="hll">|   CallExpr                { /* empty */ }
</span><span class="hll">|   &#39;(&#39; Expr &#39;)&#39;            { /* empty */ }
</span><span class="hll">;
</span><span class="hll">
</span><span class="hll">ReadInt:
</span><span class="hll">    T_ReadInt &#39;(&#39; T_StringConstant &#39;)&#39;
</span><span class="hll">                            { printf(&quot;\treadint %s\n&quot;, $3); }
</span><span class="hll">;
</span>
%%

int main() {
    return yyparse();
}
</pre></div>
</div>
<p>makefile 文件： <a class="reference download internal" href="downloads/makefile3"><tt class="xref download docutils literal"><span class="pre">makefile</span></tt></a> ，内容和 第 0.5 版是一样的。</p>
<p>测试文件： <a class="reference download internal" href="downloads/test3.c"><tt class="xref download docutils literal"><span class="pre">test.c</span></tt></a> ，就是第二章的的示例源程序。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;for_gcc_build.hh&quot; </span><span class="c1">// only for gcc, TinyC will ignore it.</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>        
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>        
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">print</span><span class="p">(</span><span class="s">&quot;%d! = %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">factor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factor</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>测试文件包：<a class="reference download internal" href="downloads/samples.zip"><tt class="xref download docutils literal"><span class="pre">samples.zip</span></tt></a> ，包含了 7 个测试文件。</p>
<p>测试脚本： <a class="reference download internal" href="downloads/test_samples.sh"><tt class="xref download docutils literal"><span class="pre">test_samples.sh</span></tt></a> 。</p>
<p>Pcode 模拟器： <a class="reference download internal" href="downloads/pysim2.py"><tt class="xref download docutils literal"><span class="pre">pysim.py</span></tt></a> 。</p>
<p>这个版本在第 0.1 版本的基础上，进行了以下扩充：</p>
<blockquote>
<div><p>词法分析文件中：</p>
<blockquote>
<div>增加了 T_Void 和 T_Return 类型的 token ，以及相应的正则表达式。</div></blockquote>
<p>语法分析文件中：</p>
<blockquote>
<div><p>增加了 IfStmt, WhileStmt, BreakStmt, ContinueStmt, ReadInt 等非终结符以及相应的产生式，请注意各产生式的折叠顺序以及相应的 Pcode 生成顺序；</p>
<p>增加了比较运算符、逻辑运算符，以及相应的优先级；</p>
<p>在 Declarations 段，增加了几个全局变量和宏：</p>
<blockquote>
<div><div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">itop</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">istack</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">ww</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wtop</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">wstack</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

<span class="cp">#define _BEG_IF     {istack[++itop] = ++ii;}</span>
<span class="cp">#define _END_IF     {itop--;}</span>
<span class="cp">#define _i          (istack[itop])</span>

<span class="cp">#define _BEG_WHILE  {wstack[++wtop] = ++ww;}</span>
<span class="cp">#define _END_WHILE  {wtop--;}</span>
<span class="cp">#define _w          (wstack[wtop])</span>
</pre></div>
</div>
</div></blockquote>
<p>这些全局变量和宏配合后面的 if/while 语句产生式中的 action 使用，是该文件中的最精妙的部分，它们的作用是：在生成 if 和 while 语句块的 Pcode 的过程中，给相应的 Label 进行编号。它们给每个 if 语句块和每个 while 语句块一个唯一的编号，使不同的 if/while 语句块的 jmp 不相互冲突。其中 _i 永远是当前的 if 语句块的编号， _w 永远是当前的 while 语句块的编号； ii/ww 永远是目前解析到的 if/while 语句块的总数。</p>
</div></blockquote>
</div></blockquote>
<p>将以上所有文件都放在当前目录，在终端直接输入 make test ，将自动编译生成 TinyC 前端： <strong>tcc</strong> ，并自动调用 tcc 将 test.c 编译成 test.asm 文件，内容如下，和第 5 章的手工编译的结果差不多吧：</p>
<div class="highlight-text"><div class="highlight"><pre>FUNC @main:
	var i

	push 0
	pop i

_begWhile_1:
	push i
	push 10
	cmplt
	jz _endWhile_1
	push i
	push 1
	add
	pop i

_begIf_1:
	push i
	push 3
	cmpeq
	push i
	push 5
	cmpeq
	or
	jz _elIf_1
	jmp _begWhile_1
	jmp _endIf_1
_elIf_1:
_endIf_1:

_begIf_2:
	push i
	push 8
	cmpeq
	jz _elIf_2
	jmp _endWhile_1
	jmp _endIf_2
_elIf_2:
_endIf_2:

	push i
	push i
	$factor
	print &quot;%d! = %d&quot;

	jmp _begWhile_1
_endWhile_1:

	push 0
	ret ~

ENDFUNC

FUNC @factor:
	arg n

_begIf_3:
	push n
	push 2
	cmplt
	jz _elIf_3
	push 1
	ret ~

	jmp _endIf_3
_elIf_3:
_endIf_3:

	push n
	push n
	push 1
	sub
	$factor
	mul
	ret ~

ENDFUNC
</pre></div>
</div>
<p>再输入 &#8220;make simulate&#8221;，将输出：</p>
<div class="highlight-text"><div class="highlight"><pre>1! = 1
2! = 2
4! = 24
6! = 720
7! = 5040
</pre></div>
</div>
<p>和第二章中用 gcc 编译并运行此文件的结果完全一样。</p>
<p>再把测试文件包里的所有源文件全部测试一遍，将 <a class="reference download internal" href="downloads/samples.zip"><tt class="xref download docutils literal"><span class="pre">samples.zip</span></tt></a> 解压到 samples 目录下，测试脚本 <a class="reference download internal" href="downloads/test_samples.sh"><tt class="xref download docutils literal"><span class="pre">test_samples.sh</span></tt></a> 将分别调用 tcc 和 gcc 编译测试文件包中的每一个文件，并分别使用 pysim.py 和 操作系统 运行编译得到的目标文件，内容如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="k">for</span> src in <span class="k">$(</span>ls samples/*.c<span class="k">)</span>
<span class="k">do</span>
	clear
	<span class="nv">file</span><span class="o">=</span><span class="si">${</span><span class="nv">src</span><span class="p">%%.c</span><span class="si">}</span>
	<span class="nb">echo </span>build with tcc
	./tcc &lt; <span class="nv">$file</span>.c &gt; <span class="nv">$file</span>.asm
	python pysim.py <span class="nv">$file</span>.asm -a
	<span class="nb">echo</span>
<span class="nb">	echo </span>build with gcc
	gcc -o <span class="nv">$file</span> <span class="nv">$file</span>.c
	./<span class="nv">$file</span>
	<span class="nb">echo</span>
<span class="nb">	echo </span>press any key to <span class="k">continue</span>...
	<span class="nb">read</span> -n 1
<span class="k">done</span>
</pre></div>
</div>
<p>在终端输入 bash ./test_samples.sh ，将分别输出一系列的结果，典型输出如下，可以看到 gcc 和 tcc 编译运行的结果完全一致。</p>
<div class="highlight-text"><div class="highlight"><pre>build with tcc, the output are:
The first 10 number of the fibonacci sequence:
fib(1)=1
fib(2)=1
fib(3)=2
fib(4)=3
fib(5)=5
fib(6)=8
fib(7)=13
fib(8)=21
fib(9)=34
fib(10)=55

build with gcc, the output are:
The first 10 number of the fibonacci sequence:
fib(1)=1
fib(2)=1
fib(3)=2
fib(4)=3
fib(5)=5
fib(6)=8
fib(7)=13
fib(8)=21
fib(9)=34
fib(10)=55
</pre></div>
</div>
<p>至此 TinyC 前端完成。</p>
<p><strong>第 14 章完</strong></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h4><a href="index.html">首 页</a></h4>
<h4>目 录</h4>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch1_overview.html">第01章 概 述</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch2_TinyC_syntax.html">第02章 源程序 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_Pcode_syntax_a.html">第03章 中间代码 Pcode (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_Pcode_syntax_b.html">第04章 中间代码 Pcode (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5_TinyC_to_Pcode_man.html">第05章 手工编译 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch6_compiler_overview.html">第06章 编译器基本流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch7_lexical_basic.html">第07章 词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch8_flex.html">第08章 用 flex 做词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch9_context_free_grammar.html">第09章 上下文无关语法及分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch10_top_down_parse.html">第10章 自顶向下分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch11_buttom_up_parse_a.html">第11章 自底向上分析 (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch12_buttom_up_parse_b.html">第12章 自底向上分析 (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch13_bison.html">第13章 用 bison 做语法分析</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">第14章 TinyC 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch15_tinyc_backend.html">第15章 TinyC 后端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch16_tinyc_compiler.html">第16章 TinyC 编译器</a></li>
</ul>

  <h4>上一章</h4>
  <p class="topless"><a href="ch13_bison.html"
                        title="previous chapter">第13章 用 bison 做语法分析</a></p>
  <h4>下一章</h4>
  <p class="topless"><a href="ch15_tinyc_backend.html"
                        title="next chapter">第15章 TinyC 后端</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch15_tinyc_backend.html" title="第15章 TinyC 后端"
             >next</a></li>
        <li class="right" >
          <a href="ch13_bison.html" title="第13章 用 bison 做语法分析"
             >previous</a> |</li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, pandolia.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>