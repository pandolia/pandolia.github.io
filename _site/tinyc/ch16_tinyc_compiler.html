<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第16章 TinyC 编译器 &mdash; 自己动手写编译器</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="自己动手写编译器" href="index.html" />
    <link rel="prev" title="第15章 TinyC 后端" href="ch15_tinyc_backend.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch15_tinyc_backend.html" title="第15章 TinyC 后端"
             accesskey="P">previous</a></li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tinyc">
<h1>第16章 TinyC 编译器<a class="headerlink" href="#tinyc" title="Permalink to this headline">¶</a></h1>
<p>在第 14 章中，完成了 TinyC 前端，可以将 TinyC 源程序编译成中间代码 Pcode；在第 15 章中，完成了 TinyC 后端，可以将改写后的中间代码 Pcode 翻译、汇编并链接成可执行程序；现在，是时候将二者结合起来形成最终的 TinyC 编译器了。</p>
<div class="section" id="id1">
<h2>16.1 改进 TinyC 前端<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>上一章的 TinyC 后端中，为了降低 Pcode 命令的翻译难度，对 arg / var / ENDFUNC 命令的格式进行了改写，因此需要改进 TinyC 前端，使之能生成能被 TinyC 后端所识别的新格式 Pcode 命令。具体来说，对于下面这段源程序 <a class="reference download internal" href="downloads/test4.c"><tt class="xref download docutils literal"><span class="pre">test.c</span></tt></a> ：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> 
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;sum = %d&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>改进后 TinyC 前端需要生成一个 Pcode 文件 <a class="reference download internal" href="downloads/test1.pcode"><tt class="xref download docutils literal"><span class="pre">test.pcode</span></tt></a> ：</p>
<div class="highlight-nasm"><div class="highlight"><pre>FUNC @main:
<span class="hll">    main.var a
</span>
    push 3
    pop a

    push 4
    push a
    $sum
    print &quot;sum = %d&quot;

    ret 0
<span class="hll">ENDFUNC@main
</span>
FUNC @sum:
<span class="hll">    sum.arg a, b
</span><span class="hll">    sum.var c
</span>
    push a
    push b
    add
    pop c

    ret c
<span class="hll">ENDFUNC@sum
</span></pre></div>
</div>
<p>以及一个宏文件 <a class="reference download internal" href="downloads/test1.funcmacro"><tt class="xref download docutils literal"><span class="pre">test.funcmacro</span></tt></a> ：</p>
<div class="highlight-nasm"><div class="highlight"><pre>; ==== begin function `main` ====
%define main.varc 1

%MACRO main.var main.varc
    %define a [EBP - 4*1]
    SUB ESP, 4*main.varc
%ENDMACRO

%MACRO ENDFUNC@main 0
    LEAVE
    RET
    %undef a
%ENDMACRO
; ==== end function `main`   ====

; ==== begin function `sum` ====
%define sum.argc 2
%define sum.varc 1

%MACRO $sum 0
    CALL @sum
    ADD ESP, 4*sum.argc
    PUSH EAX
%ENDMACRO

%MACRO sum.arg sum.argc
    %define a [EBP + 8 + 4*sum.argc - 4*1]
    %define b [EBP + 8 + 4*sum.argc - 4*2]
%ENDMACRO

%MACRO sum.var sum.varc
    %define c [EBP - 4*1]
    SUB ESP, 4*sum.varc
%ENDMACRO

%MACRO ENDFUNC@sum 0
    LEAVE
    RET
    %undef a
    %undef b
    %undef c
%ENDMACRO
; ==== end function `sum`  ====
</pre></div>
</div>
<p>在第 14 章的 TinyC 前端 1.0 版的 parser.y 的基础上，针对函数定义、参数定义以及变量定义的语句进行改写，改进后的语法分析文件 <a class="reference download internal" href="downloads/parser4.y"><tt class="xref download docutils literal"><span class="pre">parser.y</span></tt></a> ：</p>
<div class="highlight-c"><div class="highlight"><pre>%{

#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void init_parser(int argc, char *argv[]);
void quit_parser();

extern FILE* yyin;
FILE *asmfile, *incfile;
#define BUFSIZE 256

#define out_asm(fmt, ...) \
    {fprintf(asmfile, fmt, ##__VA_ARGS__); fprintf(asmfile, &quot;\n&quot;);}

#define out_inc(fmt, ...) \
    {fprintf(incfile, fmt, ##__VA_ARGS__); fprintf(incfile, &quot;\n&quot;);}

void file_error(char *msg);

int ii = 0, itop = -1, istack[100];
int ww = 0, wtop = -1, wstack[100];

#define _BEG_IF     (istack[++itop] = ++ii)
#define _END_IF     (itop--)
#define _i          (istack[itop])

#define _BEG_WHILE  (wstack[++wtop] = ++ww)
#define _END_WHILE  (wtop--)
#define _w          (wstack[wtop])

int argc = 0, varc = 0;
char *cur_func_name, *args[128], *vars[128];
void write_func_head();
void write_func_tail();

#define _BEG_FUNCDEF(name)  (cur_func_name = (name))
#define _APPEND_ARG(arg)    (args[argc++] = (arg))
#define _APPEND_VAR(var)    (vars[varc++] = (var))
#define _WRITE_FUNCHEAD     write_func_head
#define _END_FUNCDEF        write_func_tail

#define YYSTYPE char *

%}

%token T_Void T_Int T_While T_If T_Else T_Return T_Break T_Continue
%token T_Print T_ReadInt T_Le T_Ge T_Eq T_Ne T_And T_Or
%token T_IntConstant T_StringConstant T_Identifier

%left &#39;=&#39;
%left T_Or
%left T_And
%left T_Eq T_Ne
%left &#39;&lt;&#39; &#39;&gt;&#39; T_Le T_Ge
%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
%left &#39;!&#39;

%%

Start:
    Program                         { /* empty */ }
;

Program:
    /* empty */                     { /* empty */ }
|   Program FuncDef                 { /* empty */ }
;

FuncDef:
    T_Int  FuncName Args Vars Stmts EndFuncDef
|   T_Void FuncName Args Vars Stmts EndFuncDef
;

FuncName:
    T_Identifier                    { _BEG_FUNCDEF($1); }
;

Args:
    &#39;(&#39; &#39;)&#39;                         { /* empty */ }
|   &#39;(&#39; _Args &#39;)&#39;                   { /* empty */ }
;

_Args:
    T_Int T_Identifier              { _APPEND_ARG($2); }
|   _Args &#39;,&#39; T_Int T_Identifier    { _APPEND_ARG($4); }
;

Vars:
    _Vars                           { _WRITE_FUNCHEAD(); }
;

_Vars:
    &#39;{&#39;                             { /* empty */ }
|   _Vars Var &#39;;&#39;                   { /* empty */ }
;

Var:
    T_Int T_Identifier              { _APPEND_VAR($2); }
|   Var &#39;,&#39; T_Identifier            { _APPEND_VAR($3); }
;

Stmts:
    /* empty */                     { /* empty */ }
|   Stmts Stmt                      { /* empty */ }
;

EndFuncDef:
    &#39;}&#39;                             { _END_FUNCDEF(); }
;

Stmt:
    AssignStmt                      { /* empty */ }
|   CallStmt                        { /* empty */ }
|   IfStmt                          { /* empty */ }
|   WhileStmt                       { /* empty */ }
|   BreakStmt                       { /* empty */ }
|   ContinueStmt                    { /* empty */ }
|   ReturnStmt                      { /* empty */ }
|   PrintStmt                       { /* empty */ }
;

AssignStmt:
    T_Identifier &#39;=&#39; Expr &#39;;&#39;       { out_asm(&quot;\tpop %s&quot;, $1); }
;

CallStmt:
    CallExpr &#39;;&#39;                    { out_asm(&quot;\tpop&quot;); }
;

IfStmt:
    If &#39;(&#39; Expr &#39;)&#39; Then &#39;{&#39; Stmts &#39;}&#39; EndThen EndIf
                                    { /* empty */ }
|   If &#39;(&#39; Expr &#39;)&#39; Then &#39;{&#39; Stmts &#39;}&#39; EndThen T_Else &#39;{&#39; Stmts &#39;}&#39; EndIf
                                    { /* empty */ }
;

If:
    T_If            { _BEG_IF; out_asm(&quot;_begIf_%d:&quot;, _i); }
;

Then:
    /* empty */     { out_asm(&quot;\tjz _elIf_%d&quot;, _i); }
;

EndThen:
    /* empty */     { out_asm(&quot;\tjmp _endIf_%d\n_elIf_%d:&quot;, _i, _i); }
;

EndIf:
    /* empty */     { out_asm(&quot;_endIf_%d:&quot;, _i); _END_IF; }
;

WhileStmt:
    While &#39;(&#39; Expr &#39;)&#39; Do &#39;{&#39; Stmts &#39;}&#39; EndWhile
                    { /* empty */ }
;

While:
    T_While         { _BEG_WHILE; out_asm(&quot;_begWhile_%d:&quot;, _w); }
;

Do:
    /* empty */     { out_asm(&quot;\tjz _endWhile_%d&quot;, _w); }
;

EndWhile:
    /* empty */     { out_asm(&quot;\tjmp _begWhile_%d\n_endWhile_%d:&quot;, 
                                                _w, _w); _END_WHILE; }
;

BreakStmt:
    T_Break &#39;;&#39;     { out_asm(&quot;\tjmp _endWhile_%d&quot;, _w); }
;

ContinueStmt:
    T_Continue &#39;;&#39;  { out_asm(&quot;\tjmp _begWhile_%d&quot;, _w); }
;

ReturnStmt:
    T_Return &#39;;&#39;            { out_asm(&quot;\tret&quot;); }
|   T_Return Expr &#39;;&#39;       { out_asm(&quot;\tret ~&quot;); }
;

PrintStmt:
    T_Print &#39;(&#39; T_StringConstant PrintIntArgs &#39;)&#39; &#39;;&#39;
                            { out_asm(&quot;\tprint %s&quot;, $3); }
;

PrintIntArgs:
    /* empty */             { /* empty */ }
|   PrintIntArgs &#39;,&#39; Expr   { /* empty */ }
;

Expr:
    T_IntConstant           { out_asm(&quot;\tpush %s&quot;, $1); }
|   T_Identifier            { out_asm(&quot;\tpush %s&quot;, $1); }
|   Expr &#39;+&#39; Expr           { out_asm(&quot;\tadd&quot;); }
|   Expr &#39;-&#39; Expr           { out_asm(&quot;\tsub&quot;); }
|   Expr &#39;*&#39; Expr           { out_asm(&quot;\tmul&quot;); }
|   Expr &#39;/&#39; Expr           { out_asm(&quot;\tdiv&quot;); }
|   Expr &#39;%&#39; Expr           { out_asm(&quot;\tmod&quot;); }
|   Expr &#39;&gt;&#39; Expr           { out_asm(&quot;\tcmpgt&quot;); }
|   Expr &#39;&lt;&#39; Expr           { out_asm(&quot;\tcmplt&quot;); }
|   Expr T_Ge Expr          { out_asm(&quot;\tcmpge&quot;); }
|   Expr T_Le Expr          { out_asm(&quot;\tcmple&quot;); }
|   Expr T_Eq Expr          { out_asm(&quot;\tcmpeq&quot;); }
|   Expr T_Ne Expr          { out_asm(&quot;\tcmpne&quot;); }
|   Expr T_Or Expr          { out_asm(&quot;\tor&quot;); }
|   Expr T_And Expr         { out_asm(&quot;\tand&quot;); }
|   &#39;-&#39; Expr %prec &#39;!&#39;      { out_asm(&quot;\tneg&quot;); }
|   &#39;!&#39; Expr                { out_asm(&quot;\tnot&quot;); }
|   ReadInt                 { /* empty */ }
|   CallExpr                { /* empty */ }
|   &#39;(&#39; Expr &#39;)&#39;            { /* empty */ }
;

ReadInt:
    T_ReadInt &#39;(&#39; T_StringConstant &#39;)&#39;
                            { out_asm(&quot;\treadint %s&quot;, $3); }
;

CallExpr:
    T_Identifier Actuals
                            { out_asm(&quot;\t$%s&quot;, $1); }
;

Actuals:
    &#39;(&#39; &#39;)&#39;
|   &#39;(&#39; _Actuals &#39;)&#39;
;

_Actuals:
    Expr
|   _Actuals &#39;,&#39; Expr
;

%%

int main(int argc, char *argv[]) {
    init_parser(argc, argv);
    yyparse();
    quit_parser();
}

void init_parser(int argc, char *argv[]) {
    if (argc &lt; 2) {
        file_error(&quot;Must provide an input source file!&quot;);
    }

    if (argc &gt; 2) {
        file_error(&quot;Too much command line arguments!&quot;);
    }

    char *in_file_name = argv[1];
    int len = strlen(in_file_name);

    if (len &lt;= 2 || in_file_name[len-1] != &#39;c&#39; \
            || in_file_name[len-2] != &#39;.&#39;) {
        file_error(&quot;Must provide an &#39;.c&#39; source file!&quot;);
    }

    if (!(yyin = fopen(in_file_name, &quot;r&quot;))) {
        file_error(&quot;Input file open error&quot;);
    }

    char out_file_name[BUFSIZE];
    strcpy(out_file_name, in_file_name);

    out_file_name[len-1] = &#39;a&#39;;
    out_file_name[len]   = &#39;s&#39;;
    out_file_name[len+1] = &#39;m&#39;;
    out_file_name[len+2] = &#39;\0&#39;;
    if (!(asmfile = fopen(out_file_name, &quot;w&quot;))) {
        file_error(&quot;Output &#39;asm&#39; file open error&quot;);
    }

    out_file_name[len-1] = &#39;i&#39;;
    out_file_name[len]   = &#39;n&#39;;
    out_file_name[len+1] = &#39;c&#39;;
    if (!(incfile = fopen(out_file_name, &quot;w&quot;))) {
        file_error(&quot;Output &#39;inc&#39; file open error&quot;);
    }
}

void file_error(char *msg) {
    printf(&quot;\n*** Error ***\n\t%s\n&quot;, msg);
    puts(&quot;&quot;);
    exit(-1);
}

char *cat_strs(char *buf, char *strs[], int strc) {
    int i;
    strcpy(buf, strs[0]);
    for (i = 1; i &lt; strc; i++) {
        strcat(strcat(buf, &quot;, &quot;), strs[i]);
    }
    return buf;
}

#define _fn (cur_func_name)

void write_func_head() {
    char buf[BUFSIZE];
    int i;

    out_asm(&quot;FUNC @%s:&quot;, _fn);
    if (argc &gt; 0) {
        out_asm(&quot;\t%s.arg %s&quot;, _fn, cat_strs(buf, args, argc));
    }
    if (varc &gt; 0) {
        out_asm(&quot;\t%s.var %s&quot;, _fn, cat_strs(buf, vars, varc));
    }

    out_inc(&quot;; ==== begin function `%s` ====&quot;, _fn);
    out_inc(&quot;%%define %s.argc %d&quot;, _fn, argc);
    out_inc(&quot;\n%%MACRO $%s 0\n&quot;
            &quot;   CALL @%s\n&quot;
            &quot;   ADD ESP, 4*%s.argc\n&quot;
            &quot;   PUSH EAX\n&quot;
            &quot;%%ENDMACRO&quot;,
            _fn, _fn, _fn);
    if (argc) {
        out_inc(&quot;\n%%MACRO %s.arg %s.argc&quot;, _fn, _fn);
        for (i = 0; i &lt; argc; i++) {
            out_inc(&quot;\t%%define %s [EBP + 8 + 4*%s.argc - 4*%d]&quot;,
                        args[i], _fn, i+1);
        }
        out_inc(&quot;%%ENDMACRO&quot;);
    }
    if (varc) {
        out_inc(&quot;\n%%define %s.varc %d&quot;, _fn, varc);
        out_inc(&quot;\n%%MACRO %s.var %s.varc&quot;, _fn, _fn);
        for (i = 0; i &lt; varc; i++) {
            out_inc(&quot;\t%%define %s [EBP - 4*%d]&quot;,
                        vars[i], i+1);
        }
        out_inc(&quot;\tSUB ESP, 4*%s.varc&quot;, _fn);
        out_inc(&quot;%%ENDMACRO&quot;);
    }
}

void write_func_tail() {
    int i;

    out_asm(&quot;ENDFUNC@%s\n&quot;, _fn);

    out_inc(&quot;\n%%MACRO ENDFUNC@%s 0\n\tLEAVE\n\tRET&quot;, _fn);
    for (i = 0; i &lt; argc; i++) {
        out_inc(&quot;\t%%undef %s&quot;, args[i]);
    }
    for (i = 0; i &lt; varc; i++) {
        out_inc(&quot;\t%%undef %s&quot;, vars[i]);
    }
    out_inc(&quot;%%ENDMACRO&quot;);
    out_inc(&quot;; ==== end function `%s`   ====\n&quot;, _fn);

    argc = 0;
    varc = 0;
}

void quit_parser() {
    fclose(yyin); fclose(asmfile); fclose(incfile);
}
</pre></div>
</div>
<p>词法分析文件 <a class="reference download internal" href="downloads/scanner4.l"><tt class="xref download docutils literal"><span class="pre">scanner.l</span></tt></a> 不变，和第 14 章的 TinyC 前端 1.0 版的相同。</p>
<p>将以上 <a class="reference download internal" href="downloads/scanner4.l"><tt class="xref download docutils literal"><span class="pre">scanner.l</span></tt></a>, <a class="reference download internal" href="downloads/parser4.y"><tt class="xref download docutils literal"><span class="pre">parser.y</span></tt></a>, <a class="reference download internal" href="downloads/test4.c"><tt class="xref download docutils literal"><span class="pre">test.c</span></tt></a> 三个文件放在同一目录，输入以下命令生成 TinyC 前端 tcc-frontend :</p>
<div class="highlight-bash"><div class="highlight"><pre>flex scanner.l
bison -vdty parser.y
gcc -o tcc-frontend lex.yy.c y.tab.c
</pre></div>
</div>
<p>再输入：</p>
<div class="highlight-bash"><div class="highlight"><pre>./tcc-frontend test.c
</pre></div>
</div>
<p>将利用 tcc-frontend 编译 test.c ，生成 Pcode 文件 test.asm 以及宏文件 test.inc 。对比一下前面的 test.pcode 和 test.funcmacro 文件，二者几乎是一模一样的。</p>
</div>
<div class="section" id="id2">
<h2>16.2 TinyC 编译器<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>现在可以将 TinyC 前端和 TinyC 后端整合起来了。新建一个空的 tinyc 目录，然后 cd 到此目录，之后新建一个 sources 目录，然后将以下 7 个文件放到 sources 目录下:</p>
<blockquote>
<div><p><a class="reference download internal" href="downloads/scanner5.l"><tt class="xref download docutils literal"><span class="pre">scanner.l</span></tt></a>   ， 词法分析文件，和上一节相同；</p>
<p><a class="reference download internal" href="downloads/parser5.y"><tt class="xref download docutils literal"><span class="pre">parser.y</span></tt></a>     ， 语法分析文件，和上一节相同；</p>
<p><a class="reference download internal" href="downloads/pysim3.py"><tt class="xref download docutils literal"><span class="pre">pysim.py</span></tt></a>     ， Pcode 模拟器（ python 程序），和第 4 章相同；</p>
<p><a class="reference download internal" href="downloads/tio3.c"><tt class="xref download docutils literal"><span class="pre">tio.c</span></tt></a>           ， 库函数文件，和上一章最后一节相同；</p>
<p><a class="reference download internal" href="downloads/macro5.inc"><tt class="xref download docutils literal"><span class="pre">macro.inc</span></tt></a>   ， NASM 宏文件，和上一章最后一节相同；</p>
<p><a class="reference download internal" href="downloads/tcc"><tt class="xref download docutils literal"><span class="pre">tcc</span></tt></a>               ， 编译 TinyC 源程序的脚本文件；</p>
<p><a class="reference download internal" href="downloads/pysimulate"><tt class="xref download docutils literal"><span class="pre">pysimulate</span></tt></a> ， 模拟运行 Pcode 的脚本文件。</p>
</div></blockquote>
<p>然后在 tinyc 目录下新建一个脚本文件 <a class="reference download internal" href="downloads/build.sh"><tt class="xref download docutils literal"><span class="pre">build.sh</span></tt></a> ，内容如下:</p>
<div class="highlight-bash"><div class="highlight"><pre>mkdir -p release
flex sources/scanner.l
bison -vdty sources/parser.y
gcc -o release/tcc-frontend lex.yy.c y.tab.c
rm -f y.* lex.*
gcc -m32 -c -o tio.o sources/tio.c
ar -crv release/libtio.a tio.o &gt; /dev/null
rm -f tio.o
cp sources/macro.inc sources/pysim.py sources/tcc sources/pysimulate release/
chmod u+x release/tcc release/pysimulate
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$PWD</span>/release
<span class="nb">echo</span> <span class="s2">&quot;export PATH=\$PATH:</span><span class="nv">$PWD</span><span class="s2">/release&quot;</span> &gt;&gt; ~/.bashrc
</pre></div>
</div>
<p>在终端输入 <strong>source build.sh</strong> 将编译生成 TinyC 前端 tcc-frontend 、库文件 libtio.a ，并放在 release 目录下，同时将 macro.inc, pysim.py, pysimulate, tcc 这四个文件拷贝至 release 目录，最后，将 release 目录输出到 PATH 环境变量中。现在，在终端输入 tcc filename.c 就可以利用 TinyC 编译成可执行程序了，而输入 pysimulate filename.asm -da 则可以用 Pcode 模拟器单步调试中间代码 Pcode 了。</p>
<p>让我们来测试一下第一章的示例代码 <a class="reference download internal" href="downloads/test5.c"><tt class="xref download docutils literal"><span class="pre">test.c</span></tt></a> 吧，将其放在当前目录，然后在终端输入 tcc test.c ，将生成一个 test-c-build 目录，此目录中包含了中间代码文件 test.asm 、函数定义宏文件 test.inc 、目标文件 test.o 、最终的可执行文件 test 。可以输入 test-c-build/test 来运行可执行文件，也可以输入 pysimulate test-c-build/test.asm -da 用 Pcode 模拟器单步调试中间代码。</p>
<p>脚本文件 tcc 首先调用 tcc-frontend 将输入文件（假设为 test.c ）编译为 test.asm 和 test.inc ，然后调用 nasm ，将 test.asm 、 test.inc 和 macro.inc 三个文件一起汇编成 test.o ，最后调用 ld 将 test.o 和 libtio.a 一起链接为最终的可执行程序 test 。 tcc 的内容如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">#!/usr/bin/env bash</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>!<span class="o">=</span> <span class="m">1</span> <span class="o">]</span><span class="p">;</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Usage: </span><span class="nv">$0</span><span class="s2"> &lt;filename&gt;&quot;</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="k">if</span> ! <span class="o">[</span> -f <span class="nv">$1</span> <span class="o">]</span><span class="p">;</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Error: File </span><span class="nv">$1</span><span class="s2"> does NOT exists.&quot;</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="nv">tccdir</span><span class="o">=</span><span class="k">$(</span>dirname <span class="nv">$0</span><span class="k">)</span>
<span class="nv">filename</span><span class="o">=</span><span class="si">${</span><span class="nv">1</span><span class="p">%.*</span><span class="si">}</span>
<span class="nv">fileext</span><span class="o">=</span><span class="si">${</span><span class="nv">1</span><span class="p">##*.</span><span class="si">}</span>
<span class="nv">objdir</span><span class="o">=</span><span class="nv">$filename</span>-<span class="nv">$fileext</span>-build

<span class="s2">&quot;</span><span class="k">$(</span>dirname <span class="nv">$0</span><span class="k">)</span><span class="s2">/tcc-frontend&quot;</span> <span class="nv">$1</span>
nasm -f elf32 -P<span class="s2">&quot;</span><span class="nv">$tccdir</span><span class="s2">/macro.inc&quot;</span> -P<span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.inc&quot;</span> -o <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.o&quot;</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.asm&quot;</span>
ld -m elf_i386 -o <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.o&quot;</span> -L<span class="s2">&quot;</span><span class="nv">$tccdir</span><span class="s2">&quot;</span> -ltio
mkdir -p <span class="s2">&quot;</span><span class="nv">$objdir</span><span class="s2">&quot;</span>
mv <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.asm&quot;</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.inc&quot;</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">.o&quot;</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$objdir</span><span class="s2">/&quot;</span>
</pre></div>
</div>
<p>脚本文件 pysimulate 将调用 python 和 pysim.py 文件，模拟运行输入的 Pcode 文件，其内容如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">#!/usr/bin/env bash</span>

<span class="k">if</span> <span class="o">[[</span> <span class="o">(</span><span class="nv">$# </span>!<span class="o">=</span> 1<span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="nv">$# </span>!<span class="o">=</span> 2<span class="o">)</span> <span class="o">]]</span><span class="p">;</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Usage: </span><span class="nv">$0</span><span class="s2"> &lt;filename&gt; [-da]&quot;</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="k">if</span> ! <span class="o">[</span> -f <span class="nv">$1</span> <span class="o">]</span><span class="p">;</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Error: File </span><span class="nv">$1</span><span class="s2"> does NOT exists.&quot;</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

python <span class="s2">&quot;</span><span class="k">$(</span>dirname <span class="nv">$0</span><span class="k">)</span><span class="s2">/pysim.py&quot;</span> <span class="nv">$1</span> <span class="nv">$2</span>
</pre></div>
</div>
<p>下面来测试一下第 14 章最后的测试文件包 <a class="reference download internal" href="downloads/samples.zip"><tt class="xref download docutils literal"><span class="pre">samples.zip</span></tt></a> ，将其解包至 samples 目录，再在当前目录新建一个脚本文件 <a class="reference download internal" href="downloads/testall.sh"><tt class="xref download docutils literal"><span class="pre">testall.sh</span></tt></a> ，内容如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="k">for</span> src in <span class="k">$(</span>ls samples/*.c<span class="k">)</span>
<span class="k">do</span>
	<span class="nv">filename</span><span class="o">=</span><span class="si">${</span><span class="nv">src</span><span class="p">%.*</span><span class="si">}</span>
	<span class="nv">fileext</span><span class="o">=</span><span class="si">${</span><span class="nv">src</span><span class="p">##*.</span><span class="si">}</span>
	<span class="nv">filenakedname</span><span class="o">=</span><span class="si">${</span><span class="nv">filename</span><span class="p">##*/</span><span class="si">}</span>
	<span class="nv">objdir</span><span class="o">=</span><span class="nv">$filename</span>-<span class="nv">$fileext</span>-build

	clear
	<span class="nb">echo </span>build <span class="se">\&quot;</span><span class="nv">$src</span><span class="se">\&quot;</span> and run
	<span class="nb">echo</span>
<span class="nb">	</span>tcc <span class="s2">&quot;</span><span class="nv">$src</span><span class="s2">&quot;</span>
	<span class="s2">&quot;</span><span class="nv">$objdir</span><span class="s2">/</span><span class="nv">$filenakedname</span><span class="s2">&quot;</span>
	<span class="nb">echo</span>
<span class="nb">	echo </span>press any key to <span class="k">continue</span>...
	<span class="nb">read</span> -n 1
<span class="k">done</span>
</pre></div>
</div>
<p>最后在终端输入 bash testall.sh 将对所有文件进行编译、运行。</p>
<p>至此 TinyC 编译器全部完成。</p>
<p><strong>第 16 章完</strong></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h4><a href="index.html">首 页</a></h4>
<h4>目 录</h4>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch1_overview.html">第01章 概 述</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch2_TinyC_syntax.html">第02章 源程序 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_Pcode_syntax_a.html">第03章 中间代码 Pcode (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_Pcode_syntax_b.html">第04章 中间代码 Pcode (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5_TinyC_to_Pcode_man.html">第05章 手工编译 TinyC</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch6_compiler_overview.html">第06章 编译器基本流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch7_lexical_basic.html">第07章 词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch8_flex.html">第08章 用 flex 做词法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch9_context_free_grammar.html">第09章 上下文无关语法及分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch10_top_down_parse.html">第10章 自顶向下分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch11_buttom_up_parse_a.html">第11章 自底向上分析 (上)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch12_buttom_up_parse_b.html">第12章 自底向上分析 (下)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch13_bison.html">第13章 用 bison 做语法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch14_tinyc_frontend.html">第14章 TinyC 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch15_tinyc_backend.html">第15章 TinyC 后端</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">第16章 TinyC 编译器</a></li>
</ul>

  <h4>上一章</h4>
  <p class="topless"><a href="ch15_tinyc_backend.html"
                        title="previous chapter">第15章 TinyC 后端</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ch15_tinyc_backend.html" title="第15章 TinyC 后端"
             >previous</a></li>
        <li><a href="index.html">自己动手写编译器</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, pandolia.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>
